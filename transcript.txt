
----------
...

[PLEASE STAND BY]

Is good morning. Testing the mic. If it works, if it's clear. If everything I say you receive.

>> CAPTIONER: Yes.  Welcome twoRustFest. We're happy you're here and we're also happy to introduce tout MC.

[PLEASE STAND BY]

>> Welcome everyone. It's good to be here at the first RustFest. I've been programming at rust now for a few years on and off and it's been a really crazy journey. To be here at a conference to talk about it in sort of an official capacity is very, very exciting and I'm sure it's exciting for all of you out there as well.



I want to talk a little bit about what RustFest is all about, at least, according to me. A lot of people think that a conference about programming and things like that. And a lot people have brought up this meme at RustFest that happened at portland, about Rust being fast, concurrent and great. And I think that's true and I think there's a fourth one and that's community. Can you have community with a really awesome language for me, RustFest is really about that community. Sure, we're going going to be talking about code and look at really interesting technology. At the end of the day, the reason we're all here is to meet one another to talk about something that we really love and to talk about a language that allows us to do new and awesome things.



One of the really cool things about RustFest and Rust in general is that Rust really represents a lot of communities coming together. I didn't program in Rust until a few years ago, only, because it didn't exist until a few years ago, at least in a forum that was sort of usable by the general public. I came from a background doing Ruby, Rubion Rails. Scala, functional program and I know there's a lot of people that also come from that sort of background and different backgrounds. I'm kind of curious who here comes from sort of maybe a systems level programming, C, C++. We have quite a few of those and that makes sense for where RustFest is all about. Who comes from maybe some diNam being languages like Ruby, Java script? Also a lot people, which is great. And a lot those people raised their hands multiple times, which is totally cool. Anybody coming from sort of the dot-net Java enterprise world? That's really great. Anybody who's new to programming the last few years in we also have some beginning programmers, which is really awesome. To pee, that's really what Rust is all about. All these people from diverse backgrounds, diverse technical backgrounds, diverse places, different backgrounds and place coming all together. And we're here to talk about something really, really great, which is the Rust programming language. With that being said, we're going to dive into the nitty-gritty, technical details of the conference itself and we'll start off about the venue itself. The venue you can see around here. The first thing to notice, is it's not the biggest thing in the world. With that being said. Before I get into that, photography. If you have a black lanyer around you, you are okay be being photographed. Red means you are not okay with being photographed. If you think have the wrong L customer, tell one of the organizers. We do have a quiet right over here, back to the right and that quiet room is really if you're feeling stressed because of the small size or the amount of people or for whatever reason. You can go in there and have some quiet time for yourself. We please ask you that you respect the quiet room the quiet room isn't go in the quiet room for a phone call. Once you feel better, let someone else go in there to get away from the crowd.



We have a code of conduct you can find at Berlincodeofconduct.org. Really, the gist of it is be nice to each other. We're all here to have a good time and there's no need to be a jerk. We have an emergency number to call if you have any trouble what so ever. That includes, if you get lost here in Berlin, tomorrow we're going to be walking around in the city. Berlin is a bit of a big place. So if you get lost, feel free to use this number:



You it take a photograph of it, write it down. Don't take it down now, but if you feel you should have later, come talk to one of the organizers and they can get you the number later. Tomorrow, we have a bunch of workshops. Workshops, in the world means different things to different people. People imagine someone up front, giving a lecture. That is not the way the workshops work tomorrow. They are free and open and for people to come together with shared interests, about different topics to come and learn together, meet together, explore ideas together, whatever you want to D. so we have very topics, including the web, low-level programming, maybe operating systems, something around that. Embedded program. We have cryptog graphy. Block nature. Start think going what you're interested in and we'll have an opportunity to bounce around some of those as well.



These workshops are going to be spread throughout Berlin and we'll give you more specific information where those are as well tomorrow. We're going to be meeting at the venue tomorrow. We'll have a talk in the morning. Meet here and then we'll be able to spread out to the workshops and come back in the even for the final talk. Finally air, word about one of our workshops that we have, which is the Rust Bridge workshop, a new workshop geared towards beginning programmers. So maybe you have some experience with programming before, but not really much experience with Rust and would like to learn about it then can you participate in that.

We ask that the Rust Bridge mentors be at the venue at 9:30 a.m., which is earlier than the other workshops and other workshop itself starts at 11:00.



You can find information on the RustFest website. And activities as well.

This is for any kind of activity. To the just the workshops. If you feel you have a good idea of something where you want to get a couple people together. Can you go ahead and post on this website and people can sign up and things like that. We have one event tonight that's not directly affiliated or sponsored by the event. But it's the one aim even party tonight. I believe it's their one-year birthday party. So you can find information about that at this URL here. If you want tonight to go there, there will be drinks and can you go with a bunch of people some words about politics. Tomorrow is an election day here in Berlin. So there will be some election things happening around town and also, the organizers will be out voting early in the morning. So we may start a little late. That being said, there's also a demonstration happening here, that's a right-wing demonstration. So just be aware, that there could be things cause by the that.

That's happening 1-5:00 p.m.

We'll probably be in here the entire time, so that's not a problem. But just be aware.



I forgot to bring up the Origami, but we have some Origami you should have received and you can make nice Origami things here. You can find out how to make your Origami at the URL you see on the Origami paper.



We have some very lovely sponsors that have helped us put on this event and the first sponsor is Florence Company, and he'll be telling us about the rest of the sponsors.

[Applause].



>> So this is maybe my 12th conference, and the more and more I run conferences, the more grateful I am for sponsors. It's absolutely a good thing. We have two organizing sponsors. One is my company, and the other one is honey part, who's C.E.O. Tracy has been helping us with technology and all these kinds of things and design. So I'm really grateful to them, they approached us at the beginning of the year. Actually, by coincidence, they contacted the community team that they wanted to run a conference in Berlin and contacted the RustFest community in the U.S. and they said, there's also, people that want to run a conference and this is how it happened.



We have got a venue sponsored thatted us early O. gave us a call and said, let's talk F. don't have a venue, and no funding, and presumably, no budget, come here, we'll make sure it happens. And I'm really grateful for being so flexible. It's a great team here. And I was really surprised. We have two gold sponsors that are going to introduce themselves right after this. One is One Aim, building door locks. That is a very interesting topic and they're also sponsoring this even party, which is not affiliated with the conference. We have our own even party as well that's going to happen at this venue. If you want to go to the party, it's rather small. You need to get a budget banal to get in, which can you get at their table here want so if you want to go, get a badge. Just take one. Modern cryptic technologies, Robert's going to introduce to you in a second. And [indiscernible] has been happen negligent week before this, from Monday through Wednesday and the larger tech school. And programming languages, at the Rust meetup community is also organized within the open tech school.



We have two sponsors, one is key task and the other is Thought Works we have venue appearance. Thought Works has a venue over here and other one, I want to say a couple words about, too. it's the cohop. Many people that are not from Berlin don't know the co-op. It's the working space that's a few years old and they have a concept that when the co working space closes down, it's available for free for community events. So a lot of met-ups here in Berlin, started out. Because they said F need a room, just come in and get a key and can you have us for the night. They have events almost every even, and of course running that, without any money involve for many years now. Finally, we have technology appearance. Wiring microphones. They're doing all the networking, and audio stuff and the people from [indiscernible] Records, doing the video recording. So let's continue on.

[Applause].

<< 1-ethcore.md >>

[Applause].

>> MODERATOR: So next, we have a quick talk from YAN.

<< 2-1aim.md >>

[Applause].





Ryan: So is everybody ready? Oh. Come on.

[Applause].

It's a programming conference. What's there not to be excited about?

[Applause].

So next, we have our first keynote, our speaker is somebody to get very excited about. He works from his own research, work on the compilers and language team for Rust. And the one thing I'm most excited about for Felix's talk is that it really combines something very unique about Rust. The ability to really have your head in the clouds in thinking of things like category here and he advance type systems but at the same time, having your toes rustle around inside the bits. So I think everybody here is going to enjoy what Felix Klock has to say. So welcome, Felix, to the stage.

[Applause].

<< 3-felix-klock.md >>

[Applause].

>> Ryan: Unfortunately, we don't have time for questions right announcement we're going to take a 10 minute break. And I'm sure Felix will be available at the break for questions. And we'll be back at a little bit after 11:00. Thank you very much



.



[Break Taken]





>> Ryan: Excuse me, if people can start making their way back to their seats. Thank you.



Hello, hello. Welcome back from the break. We're going to get started once again. Is everybody feeling good? Everybody's minds really warmed up? So our next speaker is coming all the way from Vancouver. Made his way over here to talk to us about a topic that's a bit on the other end of the speck rum from our last talk. Maybe you're not so familiar with Rust and this is one of your first times being exposed to language. Brian Pearce will talk about getting to know Rusts and things to love.

[Applause].



>> BRIAN PEARCE: I'm excited to be in Germany and Berlin for the first time. I showed up a few days ago and I've had some time to get into some of the food, drink and history F. anyone has a recommendation of places to G. I've got another week here, so catch me in the hallway track. I'd love to hear what you suggest. I'm also flying out to Switzerland. Switzerland has a lot of things relevant to my interest. Watches, chocolate and I'm sure it's complete he undeniable that their flag is a bug plus.

[Laughter]

Now we're here to talk about learning to love the unfamiliar. And what this is, is, it's kind of journey I had while learning Rusts. It's stuff they ran into when I was unfamiliar with compiled languages. It's use annuals and concept that is were unfamiliar to me, coming from languages like Ruby or Java script or python. In the next 30 minutes, what I want to do is I want to help introduce people who are new to language. To these concepts. That way when, they hit them for the first time, it's not going to be as big of a hurdle to get over. I want to help you kind of ease into that a little bit nicer. My name is Brian Pearce. Thank you for being with me this morning.



According to the Rusts survac 2016, 1 in 4 people being believe that Rusts has a steep learning curve. I don't think there are too many people that are going to argue that.

There are a lot of new concepts, depending on where you're coming from. Concepts that will just be new to you. Submitted that it takes three weeks to get over this hump. With that if mind, let's talk a little about frustration. Within the fist three weeks, there are things that can be barriers for people. Poor documentation or maybe the community access isn't as open or friendly as Rusts community actually is. When you hit some of these bumps, you just might not know what to do about T. don't know where to go, who to turn to. You're potentially trying to achieve something you don't know how to do in another language, and you just can't work it out here. And that gets incredibly frustrating. When you first decide to pick up a new language, have you something in mind. I want to build this or I want to do this thing I know how to do in another language. Have you a single purpose you want to accomplish, when you can't accomplish T it's frustrated.



So let's take a look at an example. When I first started learning Rusts want I wanted to port a little bit of code I had somewhere else, into Rusts. So we're anything to look at a little bit of python code. So what have you here are two function that is read in a time file and process the lines of that file, send it to a process funk, check to see if the line takes a pon. If it contains a PON, you should tell a friend. Highlighted, if highlighted, the key points in these two functions, the first highlighted lines we're going to opt file. Second highlighted line,ityerrates over the lines of that file. Cross choke see if it's a pun. Tell a friend. I want to port this over to Rusts. So let's look at what that looks like. So it's not too different. Again, the key areas are highlighted and they're probably much exactly the same. You have a file open call want you have a loop to iterate over the lines of the file and pass throughout process funk and check to see if it's a pun and again, tell a friend. Key points highlighted other it's very similar. It's almost what you might expect if you're coming from another language and trying to put something together. The thing I begin to notice when I started writing more Rust were these. The unwrap calls. I didn't know what they were for. I knew the compiler told them, they had to get the values that I wanted to get. I didn't know if it was boilerplate. I didn't know what was going on.

And I'd look at this time a file after a couple hours work and be like what, is this? I don't understand understand it. My code would have looked a lot nicer if these were inn here and that was frustrated.



I want to take a bit of a dive into why that is there, why we end up seeing it in a lot of places. So Rust doesn't claim to have maybes but it does have maybe types. Maybe is a pattern and Rust implements T via option and result. So we're going to look at option first. And how option works, it's an enum that contains some or none. It contains something or nothing. And when I first read that, that didn't seem incredibly helpful. I'm callation function, I thought every time I call a finger, I'm going to get something, like the value I expected or a runtime function. But I never expected to get nothing so I never really understand this as a concept.



I don't want to just try to entertain T. I want to talk about where it should be used and Y. so on the screen, I've got a ring. The string contains the character 7 and we're going to convert to do an integer with a Ruby Y. We get a 7. Pretty much way expect. What happens if we do it within Emoji. If I call 2Ion an Emoji in Ruby, does anyone have any clue what's going to happen? A nil in anyone else? 0 zero. Exception. You get 0. Which is not what I was expecting. Looked like a credit card number 2I. You would get what is represented as a credit card number. A malformed what, do you think you're going to get this time? 4,520, which again, is just not what I was expecting. So now, let's look at that in Rust. So we have a character, 7. Again, the room has a lot people who have been doing Rusts for a long time. What are we going to get here? We're going to get a sum of seven. If we do it with know Emoji. What do you think we're going to get here? Perfect. So we're going to get a none. Same thing with credit card number. Get a whole number. We're going to settle that number. If we did it with a malformed credit card number, we would get none. So this is interesting. It's interesting because we're getting a different response or result when the conversion doesn't work. As opposed to getting kind of like a mangled conversion that you don't necessarily know what to do with afterwards which is nice, but the thing S this isn't what I was expecting still. When I call 2 digit on a 7, I was expecting to get a 7. What I have is a sum of 7. And that's not a 7. I can't do arithmetic with a sump 7. Depending on how you understand that sent. See let's take this back around again. So we now know when we call [indiscernible] we get a value of 7. To get an actual value of 7. We have to call [indiscernible]. This gives us the 7 value we were originally expecting and this is I didn't had to litter my code with unwrap, just to get value I was expenninging to get. Coming from another language accident I'm not used to some things or nothings. I'm used to get the value they expect from my function. If we do it with the Emoji here, we get a pick. So what this means is maybe that we are initially getting, the maybe that we are getting, was there to protect us. If we get unwap, the code is not better than when we were getting values that we weren't expecting, bad one versions and things like that. The unwrap will only work on positive response from the function, assuming that actually got a value I was getting the sum or none. What I wanted was the value. But now, I can at least see where some or none becomes important. We're going to look at another example just to drive it home.



So here, I have a Ruby application. It asks user at the command line to enter a number. It uses the two integer to convert the string into a number. Checks to see if the number is a number and if it is, bring the right number. If it's not, we'll say that wasn't a number. But as we have seen in the previous slides, 2Iand Ruby will convert everything to a number. Which means, this is actually dead code. This will never happen. You will always have a number.



In Rust I would have originally written it something like this and called it the unwrap. But now, we know that's bad and wean why that's bad. And wean what we actually get is a maybe request we call a two digit. I can begin changing this to something that looks a little more like this.

I can take the maybe and now, I can check to see if that maybe is some, did I get the conversion or is the maybe none? That's nice. The maybe is guaranteeing values for us. One thing I want to point out here, this kind of if else condition really isn'tityio mattic Rusts, in a case like this we would use pattern matching. So I'm going to change that over to pattern matching really quick. Pattern matching in Rusts is exhaustive. Have you to count for every case and it's incredibly powerful and used in a lot places in Rusts. That's as much I'm going to say on pattern matching. I want to point that out in the slide. So in the beginning, when I first started writing Rust. We saw all of those unwraps. They were frustrating because I had to put them there, and I didn't understand why. Now they can see why and see what they bring, value wise to me, it's not so frustrated anymore. It's incredibly beneficial, and I can start using that. Not just in Rust, but can I begin using that type of pattern in other language that is I write.



So we're going to talk a little bit about Err handling. In other languages, there's time that is I write code, I just expects something to go long. I'm going to call a funk and, you know, maybe I'm going to get a time-out from someone's API, or a value that I wasn't expecting. In a lot of the languages I normally write, I use something like a rescue. Try and catch. Rescue crew. We're going to look at those real quick. So this is Java's try and catch. If you're not familiar with Java how it works, is if you have code that you want to execute, that you're worry body, throwing exceptions, you put it between the try and the catch. If the code throws an exception, then the between the catch and the bottom parentheses, becomes executed. In Ruby, we have begin rescue crew end. It works very similarly. We begin on rescues executed. If something goes wrong, between rescue and executed. Python's very similar. So the next session S what do we have in Rusts. I I'm writing code. I want to try and catch an exception so I'm going to hit Google and look at stack over flow. What am I anything to find? I'm going to find the try macro. Now, this looks kind of nice. It's small, simple, but approximately 50% of what every, language had. Where Do I catch the errors in I don't understand what tow do with this. So let's talk about frustration again. I know what I need to achieve. I know how to achieve it in another language. I do a quick Google search. This is what I get and I just don't seat direct comparison. It doesn't immediately make sense what I need to do with this. And it didn't really begin to make sense until I looked at combining it with the result, maybe, which was the other maybe type I mentioned. So let's take a quick look at result before I come back to how to use try.



So much like the option, which returns some or none, the result returns okay. If you get an okay. You know the functions that you called was successful. If you get an error. Something went wrong.

We're I know something went wrong when I opt file. If I want to do this in Rust. I'm going to look at our readfile function again from Rusts and there's a few things here I'm going to change. I'm going to give myself a little space. Going to highlight the two place that is I'm going to chairman first. First one is going to be the method signature. Second one is going to be where I'm actually calling file open. Method silt has a result type. And result type is a result. That lets, or that says that now something somewhere in this function could potentially go wrong, and I am going to return this result type, maybe. So now, we're going to look at tri. Tri is the second thing. Tri macro around our file open call. And what tri does for us, is it will execute the file open function and if something goes wrong, tell actually capture that error, put it into an error type or an error result type and then return an error funk immediately. So it's going to capture the error. It in the proper too much. And return funk. Now that lets the caller of this function decide what to do with it at that point. Call a file, something went wrong, then can you begin to pattern match on that, much like we did on the option type. And can you decide what you want to do with it.



You can begin mapping the error. So you can cane it on to the initial call. And if something goes wrong, can you turn it into something else. Instead of just taking the panic that file open gave you, you could add text to it. You could turn it especially a custom type. --



Last thing that you need to D. now that we are returnation result, under the assumption that everything actually went well, you need to return an okay. An okay is the other type in the result and okay says that everything successfully went okay. Like, your function did exactly what it expected you to, and now, can you return that. So now, we're going to talk a little bit about testing. Testing in Rust for me, was kind of like a bit of an up and down, it was a roller coaster. Coming from languages that have a lot test frameworks and that kind of thing. I, again, had expectations, I had how I knew how to do things in other languages, and I wanted to just like, drop into Rusts and do exactly those things, and expects it to work. And unfortunately, it didn't quite work like that. So some of some of the things for me, as opposed to Ruby or python or Java script, where a lot people write their test in a test directly, Rust lets you write every test in line. So can you define the function in Rust. In whatever file you're writing in. And immediately use the test macro that's highlighted here and define the test. And that works. It's again, not necessarily idiomatic Rust a lot of people would prefer to put it in the module. And change the sim phantom dataics how they organize that file. And can you do this. It's kind of nice, actually, once I got over the fact that I'm not doing it like I used to, I kind of like this now. When I'm looking for the test of a particular function that's modifying, I just know it's in that file, as opposed to having to search through the project and finding where those things are. Rust being one of the first compiled languages I dealt with, the other next thing that I didn't really realize at first was all of the test code, that goes in the files, and my source files is not going to be compiled in the end. The compiler strips a lot of stuff out so you don't have to worry about it. So now that we know, we don't have to write our unit tests inside the test directory, that's great. But Brian, what's the deal with this test directory -- this is where can you write your integration tests. And how the integration tests work in Rust is every file in your test directory will get compiled into its own crate. Which is why I tried to write my tests, I had a lot hair pulling and didn't really know what was going on there. But how it works S every file in here gets compiled into its own crate. So if you've written a library, what you want to do is include your library into that crate. Your test file is now consumer of your li library. It's where anyone else that's going to pull in your library would be. So can you test it from that point. You only get to test what's made publicly available. Which is nice. It's like better, true, black box integration test. But again, it's not necessarily what I expected. Some of the, nice things about Rust testing is the random order testing by default want a lot of languages have that built into their frameworks now, that didn't initially run with those things beforehand. So testing says all of your tests, instead of running in a linear process, they're just going to get randomized. Your last one will get run first and so on and so forth. Which is great. It's great this dedefaults where the test you run first, runs second.



Another thing Rust has is parallel testing and parallel testing sounds great at first. But let's talk about frustration. So if I've got some code in Ruby and I'm going to explain this the top function does a little bit of setup. It creates a directory that I'm going to do some writing to in my tests. The terdown clears up that directory completely, and the tests themselves, actually just read a file, and assert to see whether weather that file exists. So it's not doing too much, but there's a lot writing. And in Ruby, these tests pass everything single time. If import this over to Rust. I'm not use anything particular framework. So the setup is specifically in my test. Set up does the same thing. Makes sure that the directory exists, the teardown makes sure the directory is clear and then the test, actually just writes a file and asserts to see if a file exists. If I have 10 tests like this. I'm going to say 8 out of 10 of them are going to fail every single time, and they're going to fail differently. It's not going to be consistent which once will fail bithey're going to continue failing. When I started learning Rust. I legitimately ran into this problem. This exact problem and more hair was pulled. I was sit in a hotel in Portland, like, trying to blame it on everything I could, run into code and new VM's. The code works fine in Ruby it's going to work fine here. And the problem leer is parallel testing is that in a ways where you're doing a lot of I.O. or sharing resource, you're going to run into problems like this. The problems that actually are occurring, your fist test has started to run. It's make sure the directory exist. Written its file, done his ashes sertion, to make sure the file exists and the second test comes along. Make sure the directory is there. And the assertion, fist test goes, okay I'm done can't here, let's just clear this correctly out. And the second test S my file is not here anymore. Everything's failed. Everything's terrible here. And if you don't know what's happening, if you've come from a language why things don't run in parallel by default then it's not going to come to your mind at first. Oh. you know, things are running if a parallel execution. It took me a long time to realize, this was actually happening. But now they know it's happening. I know how to work around it. I know how to write better tests and not share resource. What this has done, all of my tests tar right, I'm going to think about where my code is going to run. I don't know if my code's going tend up being run parallel. I give it to someone, they can run it parallel. Have I to make sure there's not going to be a detriment to that happening and I'm going to write better tests. We're going to talk about frustration last time. The definition of frustrate by Webster Miriam, I believe, was to --



Have I one thing to accomplish and I can't. And that's frustrating. In programming, frustration can frequently mean we're learning something new. Once you have a better understanding of why those things were frustrating and you can see them clearly, you my actually find yourself applying in different places. Can you learn to appreciate those things that were frustrate being for you, initially want so now, even if you're writing more Ruby code and your Ruby code runs linearly, you're going to think about that problem you ran into, when you were writing Rust. I'm going to think about writation better test to make sure those things couldn't go possibly wrong. Next time I write a function of python I'm going to think, what were the possible result types. Like, what things can go wrong? Am I going to get responses that are just like, I'm not expecting? Is the conversion going to come out properly. Can I verify that before I work with that data? A quote from Henry Ford. For the world was built to develop character. We must learn that the setback which is we endure, help us in our marching onward. That said, the unfamiliar can be challenging. But there can be so much to learn and love, well overcoming can. And once you have, you'll come out a better programmer than when you went in. I'm Brian Pearce. Thank you very much for listening and it's been a pleasure to be with you here today.

[Applause].



>> Ryan:  All right.  Thank you, Brian, that's great. We don't have time for questions. We'll be moving on to our next talk. Our next speaker comes from a far away land, Germany. And he is very interested in security topics. Today, he'll be talking about a library he wrote in Rust for just simply binaries. Everybody welcome Kai Michaelis to the stage.



[Applause].



>> KAI MICHAELIS: Hello, everybody, my name is Kai. And today, I'm here to talk about my first project I did. A cross platform. Written in Rust. So what's a disassembler? When you program in languages like Rust or C++ you write your code, in your compiler language, that's a compile tore transform this high representation into a lower representation that's executable by the CPU this transformation is combination and get out [indiscernible] language. It has not much of the features you have in your high level presentation. You can see how this looks like. It always starts with shorthand for struck. In this case, SUB. Subis the stat arc the nemonic for subtract and after comes RSP, that's symbolic name for an internal memory area in the region, there are no ifs or loops. When you do Cole Ctrl flow, you have brach instructions where I make this check and depending on the outcome. I either continue with the instruction or start at another memory address. And use some writer to transfer text presentation, on the CPU connection. This is more more or less, a one on one method. Most of the time, you're in ray situation where you have a program, and you want to know thing about the program, but you don't have the soft code. This is often times, proprietor software and with proprietary software, it has some protocol implemented and want ton how this one. Disassemble it, and try to find out from the patterns of the implication how Ts with.



Other situations, it's more how did d it get into the system, how does it spread, how did d it hide from the user and how does it get the information. So it's not the first application you can use now, roughly for under three category. Have you simple tools. These are often parts of larger compatible interests, and they are only there for analyzing the interest. And there's not much more. There's no [indiscernible] done. Then have the prototypes. Binary elements, in the selected field of research, there's a lot of research going into what can do in this binaries and these things are very impressive. But they're not really, they are to be used by nonexpert users. So they are always labbing documentation, and if you didn't read the research paper, you won't be able to use them. And then the commercial offerings. That are ate indisbetween those 2. They're easy to use. And they have parts documented. It's proprietary software. They can do some things, they can change some parts but not everything. And they cost obscene amounts of money.



Projected started in 2009. I wanted to analyze some proprietor application, and there must be millions of them, and none of them were actually useable on my machine. So there were some softwares that -- there were commercial offerings that didn't work. So I thought to myself, how hard could it be turns out, it's hard. I was told you have to throw one away. Between 2009 and 1011, dia lot research in how to build these kinds of things and analyze the stuff can you do on them and sometimes, I program myself into the Corner whericn't get out. And sometimes, these were never meant to be really extensible. So in 2011. I started with the real thing, and I start with the C++ at that time, it start to improve the standard again, and I thought, I might as well use that. Until 2015, grew to a size of around 10,000 and Rusts came and solved pretty much all of the problems I had for C++ and it took me a few months to convince myself that, again, taking all this code, I was the contributor to this problems all the type. And in writing it again, alone, was best thing to do. I'm here to convince you, this was really a great idea.



So in June, I start, and it went really good and I was surprised how fast it was. In October, I was at the point that the Rust version has the same feet feet features as C++ version. I got rid of a lot of code, mostly because Rust alluse allows me to better match, and this means have you to do computable programming, which is very hard tow use and gets [indiscernible]. So this is some boring metrics about the current state of the project. What's maybe a bit interesting is how much went up. 30%. This is not good. But it's definitely better than before. I had 50%, maybe. And this is mostly because testing in Rusts is super easy. You can put a test in line with the code. You have to remember to test all the funks, and this wasn't working for pee me at least. I have 980 Rusts points on the computer.



So what is the current state of the project? You can open up, you can open the standard format for binary systems, and instructions -- but again, a list of functions. And the functions, you get pictured here, a control for graphs so you have these, each box represents one sequence of the cord that's executed, always. So you know there are no jumps inside this box and no one coming out from the end. This really add to the flow throughout this program and analyzes. So what it can do then, is add comments to the sides Q. figure out what the funk does. Can you give it a name. For example, proprietary application. Can you read the functions of a matching number. M.O.S.6502, which is the [indiscernible]. That's pretty much it for now. So how did this conversion go? It was really fun. I have experience with C++ and comparing to them, this was really fun watching Rust and learning Rust. What I really liked in the beginning, for example. I open the book and 50%. And start to

dive dive in and you have to use something like [indiscernible] lifetimes. And program is the best way to learn, it really helped me to get over this initial bump and really got me interesting. You have this but when you compile a test, you only get the long error many.



[Laughter]



And in C++ when you have dependency to your application and people want to compile, they have done every single dependency and compilers, and you really have to go and decide if I compile it much set of pass, the binaries and this makes deployment very, very hard. So I had to think very hard about every dependency on the project. And I had no dependency. Easy to -- put dependencies in there. This way, I could reuse much of the code that was already done.



I am reimpressed how much packages are in this, compared to wop year ago. Reading ERF structure and use the code done by,s that, most of the time is written better and maintained, as opposed to the stuff that's more right on. Getting back to the application is always hard. And when I start to put in my code, I had a situation where I parted some functions and displayed the graphs. And there was some functions to do here, to remove something from that.

Way do is, remove one and so pretty straightforward. And I follow this function to Rusts as soon as possible. I have no idea what happened, but digital file. So diwell. I always do with a piece of board checker, I start exploring things more and more. At the end, I was at the point where I just copied the whole container. And this was the first time, I actually looked, and checked anything. And I realized, there was a need for the [indiscernible] problem. C++, in Rust. Plus, they are not checked or something like that.

You start incrementing until you get to the end. And muted container, these problems come from, these are rehabilitated. They are three later structures. These month Estopped being developed. If you don't do this, things will happen F. you're lucky, [indiscernible] goes up F. you're unlucky, you're like me. The Rusts, of course doesn't work because hasn't referenced others container and muted the container. This was the first time, I saw this checking thing, really finds a spot and this is something that is that is not very based and you find this all the time.



When you write and record in C++, you never know when I compiled in Rust. I know that certain box in there that can, give it encourage -- Rustsism occasions, and when you do this tract come, there is there's some part that more more or less emulates or really executes the instructions. Over flow integers are pretty complacent this is pretty annoying. I understand that my special case is probably not a general case. For pee, I'm not sure I come from C++. And in Rusts, in C++, using ate programming a lot. Duly designed to do things.











what we actually do is write them, a machine that looks for some patterns, and the first pattern T generates some structure. Now, this is the nemonic XY. This is the argument much and if you are, for example, you have thisration that's called O.I.I. immediate value. We have two arguments. For each of these operations, a CPU. You only have 100 of them. More more or less looked like the -- in the other half you see what is in the reference documentation, and can you [indiscernible] copy for reverse itch implementation and this makes it easy to check qualify these things are correct. One bit, for example, T does work. And you have a function to it. So what happens, the Rust cost function and eventually, creates all the meta data in that situation, I have cogeneration of macros, it can understand what nemonic operation actually does. This enables us to do a little bit more. And this, for example, tells you how data flows throughout implication. You need to define some kind of intermediate language. Like compiler. This is ray part that generates immediate construction that is easy to be analyzable. And uses rays. RAEIL. Kind of a standard, and I built a macro, which was more Les, the derivations for another. An assemble ler, for 6502. And it looks like the fight and applications and research papers. Again, you can just copy your stuff into the macro and then makes it easy to verify there are some things I don't like about Rust currently. Doing rough output is very hard. They are they allow to you draw if rectangle and stream. Bicomplex [indiscernible], that's hard to do. And I use QLRS this is another problem because cube K + and you can't interact C++ directly. Just makes it hard to deploy. And then -- you have to declare independency beforehand and then you use then. That's a problem. The guys have enough to solve. But for me, that means have I to wait until the problem is solved before I can try to get the official package which is really important. Because publics and so O. and one last thing about, I really like [indiscernible]. I wish they were a bit more flexible for example, tree part. I use it and I know what products but I don't really know how it works.



Why I'm really here is to tell you about my projects, and you will help me because I'm programming more or Les alone. Miurus is terrible and there's a lot of unrep in there and a lot of okay and unrep. And just returning this to an error, already sufficient to get a request in there. If interested, the website is:

And for the problems is.

Panopticon.re.

And E-mail is@ _{~cibo _ .

And that's T.



[Applause].



>> Ryan: So we do not have time for questions but we will have a lunch break after the next talk. So our fixture speaker coming up told me a really funny story about his Zuck into open source. He Sundays a couple of thousand lines of code to the maintainer when he was about 14 years old and never heard a reply back from that.

So E-mail, it was not formatted. So hopefully, things are going much better since then, but Tim Ryan will be talking to us about the Internet of things, and the systems with Rusts. So welcome to the stage.



[Applause].



>> TIM CAMERON RYAN: Oh. hold on. The Internet of things involves setting up monitors. So if you can seat state of the Internet of things right now. Hi, everywhere. I love being the talk before lunch because it ends in lurch, which means my talk always has a good ending to it. So hopefully, you're all psyched for that.

Thank you for letting me talk here today.



My name is Tim Ryan, I'm a developer from the U.S., I've lived in San Francisco worry two careers, and then, most recently, moved to Boston and that entire time, I've been working on developer tools, specifically, developer tools for devices for drones, for basically any problem where a software developer would say, hey, I want to sense that or talk to that or move that around. Anything outside of the confines of what a computer or a phone can do, I've been interested in and I know that the talk has Sirvo in the tideel which is the name of an experimental web browser. Unfortunately, I'm to the knot going to talk about it at all. So sorry about the disappointed. So things one the Rusts talks, like the hobbyist motor. Hopefully, in the future, I'll make it up to you and talk about Servo talk to the browser.



How does Rusts interact with hardware and circuits? So the biggest problem in hardware, I have information or there's something I want to accomplish. How Do I want to talk to it. Million you have a laptop and temperature sensor, which could look like this or you just have the idea that I want to go ahead and see what the temporary in the room is essentially, some of these can you plug into your laptop via USB. But most likely they can talking some embedded protocol. You need to build a circuit on the other hand them and what is the standard in Rusts in order to want to circuits, is it just like reading to a file system, talking to a web server? A lot of software developes probably don't van an log for what this looks like, evening if they go and develop the circuits. Especially because Rusts is built around developing laptops right now. Let's say I even solve this problem. I have Rust code and I'm talking to a sensor and this is happening at my home and I am now, 3,000 miles away.

And I would love to know from my mobile phone what, temporary is in Boston, pass mass and my house. Is it really cold right now. Is my house burning down. I don't know. These will be great questions finding out. This is the other problem of Internet of things, which is connectivity. A micro controller board is a breakout board with its own CPU on it. You plug it into a computer and you develop for that target. And that is what communicates to a device. A lot of these board vs. Different pins on them. Basically, little ports, that say can you wire this to a circuit and these pins do various functions, sometimes specializized, sometimes not. There are a lot of common once you might be familiar with. For example, at one end of the spectrum is micro controllers. Here I have have eighteensy board, it's a micro controller, uses one from free scale. It has 32 pins on T. it may have a few hundred kill bites of memory. It is a completely different programming model than what you're use touchdown it's probably single threaded. You don't really have to worry about memory races. You're not really maintaining orship. It's actually just one somewhere space. You don't need a lot of the guarantee that is Rusts provides U. and we'll talk about that later it's a very exotic programming model. At the other end of the spectrum, you have micro processors. The raspberry pie. In an embedded computer. And it can do high-level tasks. Say it is ruppation python science library or a GPU. The micro processor, has its open GPIOpeps, which is to say, it can talk to a circuit. The biggest difference is on the micro controller side. Reliability is keep the predict ability is key. You're doing things as fast as a processor can do things O. the micro processor, when running Linux, you have a scheduler. Things are competing for miles an hour, compete for example time. You can't do real-time things most often on a micro processor, when you're doing something built on a standard raspberry pie distribution.



For the past few years, I've been working on a prejudice called teasesel, another micro controller board. I've been excited about T. because it's fully open source hardware and for our particular example, it tile has a hi crow processor and a micro controller. We can get the best of both world I've been working on it since 1013, originally, it was a company and now issue it's an open source group with a small steering committee, and accepts open source contributions.



Originally, we targeted OJS. All of our libraries are written in OJS. Our command lines, et cetera. And more recently, because Rusts reached maturity, with 1.0. We've been excited to say, let's develop an environment caring oh, Rusts C, et cetera and bring them into a platform that's really easy so we found a lot of low-level C code. Imported it on to Java script and are now porting it to Rusts.A each time, learning a lot of other cell system like, wow, we were really young programmers back then. Another interesting thing about this, it's in the wild use of target, developing for teases cell actually, stretch happening the bound easier quaff my knowledge is about Rusts and how it cross compiles so it's been exciting to say, well, take all the features and all the extensibility of Rusts. Marry it to the development we have built out and see if we can't get the best of both worlds.



The basic hello world example is a blinging example. This is a combination of command line tools to make it real easy to get started on it. And the cardioecosystem. We can create a directory. We can say, the target language has been rust and this will create a sample repository. We can teach you rup and specify the name of the file and your tesla lights are blinking. The entire point is that we leverage the entire ecosystem. From here on out can you do same dependencies that you're using, add your own source code. You can build it into your existing system. That is out of the way.



Let's go back to basics Q. you're talking about signal says and sevos we're talking about circuits. How many of you have circuit experience? About 50% of the room. Maybe a little lower. We're talking mostly about digital logic. Means there are high and low values and they're being interpreted in some way. If I have a circuit and say, the voltage is 3.3. That is what I declare as a high voltage. Any it is high, I want to turn the light O. similarly, say, when the circuit is 0 volts, I want to turn the light off. You can get close to 3.3, get close to zero volts. Everywhere just sort of agrees when, you're close enough to these, these will be represented as those values. But this match is really cleanly to binary values. So a high voltage might be one and a low might be zero. One thing about this, is that you can actually look at this as a power source, not just as a small. I can switch it from high to low and send out a square wave, which would switch on for equal parts. And now, this is happening over time. So if I stretch out any of those signals, the light will be on for longer. Light will be on for a shorter amount time. If I blink it fast enough there are a lot of fun things can you do with that.



To what we might want to say San imperative way of generating that same signal. So we have a few lines of set up in the beginning to say, we want to get a port. We want tow know it's there so we unrap wrap it and select, IN0 and it'll loop. We want to turn the pin high. Sleep for a second. We want to turn pin low want sleep for okay second. This will generate same signal we just saw of the notoriety now, this is spiral synchronous, it's putting the thread to sleep while we're doing this.

Because we're on a bed of platform, it's okay we're doing this.



So kissed could be inputs as well as an output. An inpit pins, is this value high or low. So if I have a wire, which is connected to a high voltage and then a switch in the middle, that switch is going to break theet. So when I press down on the button, I'm literally, saying here's the material, I'll know conditioning the circuit. And in the same way, we can say, we want to turb on an LED with the switch. Can you do this with a circuit. If you were going to say, all right. There's pin 0 and pin one and we're going to select them and call them LED and switch. And then in our same loop, every time we read the switch, we say, is it switch on, turn the LED. If -- what if when the switch goes down, I make a post request to tweet that I'm home. Thats, hey, everyone, I'm home, I'm lonely, give me friends. That is the magic of hardware. We can do complexing like sensors. A sensor is basically a small IK or a chip which is able to talk some sort communication protocol. And this uses the same basics as what we were using before. Input and output values. The sensor itself, although it has a lot of pins, including power and round to GIOpence. We care about the data and clock signal. These two in combination, allows for talking to the micro controller and malicious something in -in-the- out world.



Those two things, data and clock pin, can be wire to the protocol, I2C, which is a protocol dating back 30 years. And this is an agreement between the two processors about how the signal oncer New Mexico same way that your web browser Uyour smart watch, pacemaker, all of these understand http. Eveno though it's just plain text, it's sort of similar to this.

There's two signals and the way they modulate each other. That is what determines what the signal S. everything time it goes up, you might measure a data on the value line.



The basic agreement here is when the data lines go low, the processer will emit clock fixing. The I.C., will write back and say good. And then we'll write over a bit another over to T. the key point to notice about this is that it's happening at 100 kill Hertz. So if you member human can measure hurts. A hundred kill -- your PC is probably running --



When you were trying to to these perfect communication protocols you're not going to be sitting there, flippation switch on and off in order to say what the sensor should read. It's going to be handled by something at a lower level. They exist with your USB controllers, the way the lap talk talks to your screen. We're going to tell the what to do. Do some black magic and then give us a result, whether it's the input that we wantd to read over the output. So what do we do when we have a low level protocol that we want to wrap in a high-level system? We write an A.P.I. for T. here's the came example. This is using all the lower level primitives we want. We fist do a transfer to the address, 0X1D. Can you please send me back the registered value. Woe say, this is our handshake value. We know we're talking to an accelerator rate.



What it boils down to is we now have a two fold of 3D success aleration factors, depending on which way we we angle T we will get different values here and that was gist four teamlip of codes in arbitrary I.C. and started talking to it you might look at that and say, pretty ugly. Let's make it nicer, creatan accelerometer. Expect that it is actually connecteds to and read the acceleration. And you can go do Ohio right now.



One key thing about Rusts here is that we actually have a very strong advantage of using Rusts over any other system language that I've used. Especially if we're using Java script in this case, let's million I was trying to write at the same time, at the same time. I have an LED and I want to suspected it high or low but I have the ports upon. It happeneds to send its signals Q. we have apITC port, we can write some data if we want to accidentally send a high value because we want to turn LED on. But we do it on the wrong pen, we can say, Rust Bridge will prevent this from doing

.



Basically, in designing this, we realize that Rusts provides high level objection extraction for things, and allows us to do it in a way that's really approachable. Really, you would want to encourage anyone to be able to talk to an arbitrary crimp. To do the logic. And this, the quote I read from Rusts camp last year, do programming in place you were afraid to do it before.



Another way of phrasing is have without fear. This is also the quote they used last year to sort summarize the Rusts methodology. So I actually started hacking away at things. Power words, in order to fake a few demos. On the left, you see the two leads pointing out. You definitely shouldn't plug this in and touch the bolt at the same time or either of them. But they do plug into a circle really well. On the left Othe right here is a warning that I actually stripped off of the power strip saying, specifically, don't do this. So given that there are no more warns. We can go ahead and produce a demo. So over the past pretty much, the past two weeks, we went shopping. Bought a bunch of sensors and came up with five different crate that is exemplified different sensors, blue tooth energy. Climate sensor. And so for the first example, I want to go back to the accelerometer demo. I want to check the temporary of our home. If it's too hot, I'm going want to to up the temperature sensor. For the, one, I want to say, pick a relay, a very high-powered switch and write to it saying hi High to turn on the switch or low to turn off the switch.



I'm using a web server, host on the teasesel and I'm going to hit start cooling button. So can you seat temporary dropping inside the Tessle itself. But you believe me any way. We're actually reading life temperature data can you imagine if I was a mile away, in Berlin, we tried to measure this at my house. I want to be able to go home, turn on the air conditioner, 30 minutes before I arrive. So a very simple example, using a micro controller and a few sensors. Next one I want to show you, an actual use of the Servo. A hobby motor that can turn from 0 to 180 diagnose. And best part about a Servo, is it can turn to a fixed point. Unleak a motor where you're saying, go forward, go backwards at a certain speed. Servo can have certain positions on them. And this one is actually very similar to the demo that we saw earlier today. Where it's turn on light automatically when you walk into a room. This can also scale to, I want to unlock my door when I approach my door. But we're going to start with the Servo crate and a blue tooth low-energy model and do a low quality version of this. So easy approach the front door, a sensor inside is reading blue tooth ID's and servo is noon turn the light O. when it detects the blue tooth ID of my phone, as I look proudly over my domain that.

Took 20 lines of code.

[Applause].



Entirely Rusts code, that is doing things, with sensors, in Servas, that is very like, applicable to our daily lives, like, we are developing companies around these I.O.T. Connecticut septs. Buying new products around. So in true Rusts fashion we have been to ask ourselves is, are we I.O.T. yet? I don't want to give a definitive answer yes. I'm just one developer in a full of you. I want you to borrow.

Problems is security, reliability and power. A few years ago, we had the shellshocked bug, was bug that allowed to you do a buffer overrun in a router so essentially F sent a malformed http to a router, it would run past the buffer it allocate forward that. And you could get repot code execution on T. remote code execution isn't a big deal itself. But the idea you have a router in your home, in millions of homes and you can't update those, that's how many. You really have to get security right the first time by make sure you have all these guarantees. It happens at the O.S. level and S.E. left Lynn crux. But Rust Bridge is the final defense for what puts into your program and what you're going to be able to do.



Second one is reliability. And I don't mean this in the way that my blue tooth is suddenly not working. Or my app crashed. Rep liability means we are going to continue to put these on our diss, to protect our children, to protect us while we're driving cars. Technology ising so many cop com.s of our lives. IOT gets a Pat blah. Even though every system has its own trail tee, when you do these embedded system, thank you really see that a lot are M. so when we're talking about explicit error handling or the ability to not have your program crash at random. Like, the extreme wop day, this might be it'll save you time money if you're not dedugging these things. So Rusts does a real investment.



The last one is power. We talk about zero cost allocation and these are hugely important when you're doing bench marks biit's very important when all you have is like a few kill bites of memory to spare, and I think what julia ef ABC said off our Rust Bridge conf, if there's going to be a new generation of I.O.T. developes, they're going to rup into these problems. D.



Most month, an embedded sen aryear, it's a cost between answer trust transaction and doing safely and hope it works I'm going to leave I off with some goals. Cross compilation has been like air, goal standard for rust right now. We also have my A which sets the baseline for working out all these different operating systems. Upon why ph why you're watchation a bear is nice to have. But there are more platforms than that. As it becomes more popular. We should really think about what is it going to be, this constant scheme uphill. Is it something we maintain.



The second question is can we have a goal of combining real time and non-rel time systems. Basically what, this boils down to for embedded. Is, can I provide synchronous and A sinks in system. Zero allocation -- sorry. Zero allocation on computers, possible, which is an amazing boom for anybody anyone writing high performance code F. you look at a low embedded system. You may not have the option to use threads. So as we moving forward. Being able to target low, embedded platforms. It's still something.



Another goal is to see Rusts at its lower level. There are a lot of embedded presence, including Skink and Talk and there are hardware problems in Rust Bridge. Specifically typed to do what I was demonstrated today to, talk to circuits. There's more. In the server, the sensorily bear they wrote today, currently only work on one platform K. we design a foundation that brings all these things together. If we're able to do that. I think Rusts, where previously, we would pick C++ for robotics. C for embedded systems, and maybe Java strict for system like servers and browsers. We make rush wop of the prelanguages of the Internet of I thinks. I hope you share with the credit. Thank you very much for let ming talk today. Can you see any of the code demos at Ruststest 2016 and see what I'm working on at Tessleel Rusts. Go enjoy your lunch.



[Applause].



Ryan: Thank you very much. Unfortunately two have time for questions. We do have time for lunch. Take your seats real quick. Lunch works in ways that you may not be used T. at a conference, there's no getting up that's necessary. We bring out lurch to you, since we want to make sure that everybody has space here. If you want to eat your plump inside, that's fine. If it's not raining tooad badly, you can get it outside, as well.

With that accident said, we will now bring out the lunches to you.



[Applause].



Thank you.



[lunch] the sit down part is just until I finished announcements. If you want to stand up, can you stand up. Can you remain seated as well.

But we will bring out lunch to you.



[lunch]

Ryan: Attention, everywhere, we're going to be getting started soon. So make your way back. We'll be starting soon. All right, welcome back. Did everywhere have a great lurch. Yay! . You may want to take this opportunity. To like, shake yourself up a little bit. You know, get over the big bowl of food. We have a great talk up next. But first a couple announcements. I want to tell everybody, this is a community conference, and a big shot out to our organizers who have done a really awesome job organizing this thing. Can we have a round of applause for the organizers?



[Applause].



There was a special gift given out M socks. And we have something very special prepared for you as well. Unfortunately another not socks. I apologize. But wait. You can't take that piece of Origami paper we gave you earlier. If you follow this URL, I will teach you how to fold your paper into sox. So that's good. So yes, we do have socks at . It's great.

I believe there was something called self-y stick fencing happening, so if anybody wants to participate in that or post your own ideas for events and get people excited about other things, then that is there for you and there's the URL again. All right. And I think that is the end of the post lunch announcements.



Next, we have a talk, near and dear to my heart, a project I've contributed. And Ashley will give a talk, so everybody give a warm welcome to Ashley Williams.



[Applause].



>> ASHLEY WILLIAMS: All right there's some small tech work we need to do here here. Start the screen recording as well.

Computers. How do they work. There we G. hi. My name is Ashley. You may know me as GW dubs from twitter and I'm coming you to you from not exactly the Rust community, but I work at this little company called NPM, which is keened of like the cargo for no JS, which is a runtime for this language that everybody loves to him but I really love Java scrip. Do I quite a bit television if node. I used to be a Ruby developer and I've even dabbled in Erlang, which is a super cool language as well.

I really love programming languages. Part of the reason I love programming languages, I really like to think about thinking. In particular, the type of thinking that what happens people write code and this is personally, because my background is as a teacher this.

Kind of led me to influential called intermesos. I'm going to continue to say we, because it's a collaborative project. But it's a teaching operating system. So intermesos is a teaching operating system. Focused on introducing systems, programming concepts to experienced developers from other areas of programming. We anticipate that you have probably programmed in something. But it really doesn't matter away.

And in particular, the program of intermesos is for people whom system program suggest terribly not friendly. Probably the best way to say it is, do you know Java script? Why don't we write an operating system together?



The origin of this project is because somebody, who will go unnamed but who looks exactly like their twitter "Avatar" accident asked me this one night. They said, do you want to stay in and put on some comfy pants and do a neat Colonel tutorial. Circle yes or no. Oh, heck yes I do, that's awesome want is like, let's get close to the metal. That's what the real programmers D. side bar. Real program suggest not a thing. So definitely don't say that.

But I was ready to get close. This is something, and I had this immediately, I thought oh, no. An operating system. Like can I write an operating system and should I write an operating system. A question we don't often ask ourselves. And part of the reason I had this feeling is best tembest demonstrate by the this amazing website. OSDev.org. Has anyone been to this website? Full disclosure. Thing website is horrible horrible. This is the worse website. One of the worse pieces of Internet I've seep and there are terrible things remember and the reason I'm so mad, this is the required knowledge page for OSDev. Let's take a look at some of things they state. So basic computer science. You need to be intimately familiar with hexahexades mal. We'll see how much you know. So no. What intimately you know. Programming experience. Learning about program withing an OS problems is considered a bad idea. I feel like this term considered a bad idea or considered harmful is done and I'm done with as well.

But last but not least, fail tower comply will make you look silly.



[Laughter]



Okay. Now, I'm really take theming seriously. Definitely, not. So enter this tutorial that we happened upon on the Internet. Writing an OS in Rusts. And it's a series of Blog posts that take you from absolutely nothing, into an operating system that you are able Tex tend, however you'd like in Rusts. Which is super cool. What's important is that it's the exact opposite of OS Dev.org. Hey, you're not stupid because you don't know this.

We are not going to continue to refer to you read books that we don't actually list on the website. No. We're just going to be like air, this is what this thing S. why don't do you. So the real title of this Doc is I can operate a system and so can you. All right. So this is the treat I got when I got my operating system working. This is my hello world from Rusts in my very, very small operating system. And what is an operating system near you telling me this thing with this tiny blue thing here, hello, world San operating system. Yes. Yes. Actually, this is an operate system. It is extremely small but it is indeed one. So the question here is what is operate system and it's actually kind of a complicated thing, potentially, but the way I like to define it is, an operating system say program that provide ace platform for other programs. It provides two things to these programs. Abstractions, and isolation. So what do we mean by abstractions in I can get pretty come byia and go continental deep. And G everything is a distraction upon but we can talk about that at party. For now, what I'm going to say is when you're thinking about the types of instruction that an operating system does. That program runs on hardware A. That's all fine and good until it turns out that we have hardware B. So originally, a program is officially written for just hardware A. You're not going to be able to support something like hardware B and the way you're able to support these sustick an abstraction in the middle here. So that you can z operation system A is what we have the program for and praying A is what we're epiabled to distract. We see other types of distraction when is we bring up the idea of a VM. Say into the write a program, but I don't want to write the program for any specific operating system. I want to be able to support multiple operating systems. In this sense, we can write the program for a VM and that VM extracts the way the boundary between the program and the operators system, allowing you to support both, in a very similar pattern to the way operating system abstracts over that boundary with the hardware. Now, we have got to have a Patter here, it's abstractions all the way down, but we'll sit with these, I guess. The Pat certain this.

I have A. A is written explicitly for X, but I want to support X and Y. So I put an abstraction in the middle. Now, you could say this this is what we're doing in allotypes of programming. In particular, this is what we're doing in operating systems programming. Now, the other thing that I said the operating system provide system icelation. So isolation is a little bit more difficult to talk about, particularly, because it's very closely tied with extraction. I stepped to think abstraction and isolation are two sides of the piece of paper. I think the nice way to talk about T bring into the idea of intermesos title. Conveniently, ending in an OS, intermeso meanness a light dramatic musical or other performance inserted between the angs of the play.



So as we saw before with abstraction, sort of should go in between, allowed us to be able to generalize over a lot things but additionally, it allowed us to separate things. So these abstractions and isolations, come hand and hand in hand. That's what we're doing when we're writing an operating system. So the next question I have, is operating system much everybody's talking about a Colonel. What the heck say Colonel. And it turns out this.

Comes into the question of okay. What kind of operating system are we talk B. so the definition I'm going to use for now is Colonel, is just the core component of an OS. And we can show that forever, but again, it is outside the scope of this talk. As I said, there is this question. Let's write an operating system. What kind of operating system? There's tons. I know if I mentiond to my parents, Oh, I'm running an operating system. They'd be like, windows or Mac. And I'd be like, noo. Neither. Not anywhere close. But it turns out when we're think going doing operating systems development as the thing to learn with, it really doesn't matter what kind of operating system. In fact, this question is irrelevant and this is Y. we could waste a lot of time trying to design our perfect OS. As people who only use operating systems, I'm sure we have things we'd really like it to have. So we can sit down and dream in the clouds any any type ofs system we'd want. If we did this, the chances are, we would never actually build it. With intermesos and coding in gym, the goal here is to leadership, not to make the best OS that ever exited. The type of operating system we're making right now does not super matter. All right. So let's talk about intermesos. We're actually going to dig into a little bit of the code. So for starters, there's a few prerequisites. And that's going to be some virtualization, so long as you're basically not using Linux. And a couple lip you can coincidies and a couple option that is make peering when you're peering into an operates system, easier.



While program and operating system is within your grasp much debugging is very hard on and I find building that operating system feels like coding in the dark. So for virtualization, I started to build an operating system on a chrome book pixel, so this was a somewhat hostile environment for trying to build an operating system, and I very quickly found out, I was going need some sort virtualization. Interesting enough, nearly quell equally difficult was the Mac OS. OSX, Macro S. Don't quote me. It's actually easiest to do this work on a Linux machine. But what I use for doing the virtual situation is Vagran, development environment manager, which uses virtual box to virtualize machine and experts to forward graphics, which was one of the biggest problems, particularly when I was trying to do some of the chrome book pixel. So this is, maybe I thought what was really amazing. Original Philadelphia inoperative tutorial, he had written it exclusively for Linux. My name is now in the tutorial for being like, hey, if you're stuck in one of these environments, use this lady's vagrant file because you can be running up in a second. I'm like oh, my gosh, I'm in the big leagues, this is so neat.



Once have I an environment that's virtualized, you're going to need Linux dependencies, these are very new for me. But Nasm is what we use as the assembler. Took the assemble ler and put it into binary and L.D. which was a linker, made by the other files. Then we had grub. Which we'll talk a little more later. But that's the bootable ISO. And I don't know how to pronounce that one. Chorizo. That's not right, but I'm going to call it that now. Finally, you have Kimu, which I do know how to pronounce. I call it a fake computer emulator. Which is pretty much exactly what it does. All right. Then finally, we had a couple utilities. You don't need these but they are super nice for viewing the generated code. It's difficult to peer into some of these things, especially after assembled and compiled. I was excite that would I'm not the first person to mention [indiscernible] today. Did not anticipate that would come up in another talk. We have hexadump and Ovs dump, which will allow you to view some of the code you're generating. All right. So one of the things I found the most tricky when think going develop ang operating system is like, I don't really, really know where to start. I need to ask myself the question. Okay. What are the tasks that the operating system needs to do? So it turns out, I really needed to answer this question . what happen when you say turn on your computer. And so I'm a huge fan of having a generalized journey, like, description. To understand what's going on.

So in my mind, the way the things happen are, the hardware loads bio, which stands for your bisque input/output service. And bios loves grub. Grand unified boot leader. And I million a weird cater-P-type worm with a crown on it. That's Grub for me and finally, Grub is going to be what loads our kernel.



One of the big things was linking and that is that L.D. utility I mentioned earlier. What the linker does, is figures out how the sections of the input file should be matched in the output and should really the memory layout of the output file. In intimacies on right now, the only thing you need tonight with linking is you have two things and you really need to make sure that one comes first. So linking, just make sure the header inno no is up at the top. And we'll show that code in a second. So speaking of show the code, now, it's time to do the temO. this is where I hope you all show me your hexadecimal skills. I'm ready and excited for that.

So let's pop this open. So I already have this. How are we doing on slides for that? Can everybody see? Pretty good. Okay. Fantastic. So right now, I'm here in vagrant and we have mellow -- oh. I'm turning that off. That's horrible. All right. So here are the file that is we have. So just to talk quickly about what we have in here, the first file is multiheader.asn. It's going to say, hey, I am something you can load with multi food. So this is the thing that Grub needs to see to see it knows how to note T. second thing that's important is this boot.asm. This is going to say, okay, grub, you know I'm the best thing can you use with multi boot. What are you going to do once I get booted? And here, we have the linker.LD file. That's saying in there just make surety header comes first. If Grub doesn't know what I am. We're already in trouble. So what I want to point out here, let's take a look at the boot file. So here is some very lovely assembly here. And so what we can see is we have all of these move word statements. So let's break down what these mean. So move is going to be the instruction. Word is the size and then it is next thing that comes is the pointer to where we are going to put it in memory. Then we have this little concoction right here. What happens here is the first two characters are going to describe the foreground and background color that we would like to display on our screen. Then the next is going to be the character that we're showing. So just to show you what this ends up looking like. Turn that off. I am so sorry. It says off. Can't account for T. so what we can do here, we can say make run. And this is going to pop this up. And here, in the Corner, we can see that it says hello world. This is an operating system. Yay! This is really cool.



Now, let's go to where we can get it to say, hello RustFest.

Does anyone know off the top of their head what capital R is? An ASCII. Oh, want that's Borg. Wow. Tough crowd. I would just like to point out that nobody is jumping to say what this character S. so your deep knowledge of hexadesimal is make me sad. I have this baked in my important secret speaker notes. So these letter vs. Changed. But let's just take a look and see what this ends up saying. We can say run. So it says, hello rest fian ... which is almost close little but it turns out writing all of this assembly, isn't, you know, I mean, it's cool. You can wake around and say, ah, writing assembly and everyone's going to be like, I don't know what that is. But I bet it's awesome. But nobody really want a program like this.

And here's the deal want the level of fail I can have much I can have this cheat sheet if I type out some numbers the it'll be a mess and turns out the error immensely aren't error manies, it would just not work or it would print something random and it would be really hard to debug. What happened was relatively complicated and we had a pretty fine grade control over what we were doing. So we had the bioload that boot loader grub. From the virtual hardware and boot loader read and found that multi boot header. All right. I can do this. Then it copied the boot and text sections that were inside much that, to some of course specific memory addresses and it jumps to this industry point and that's when our Colonel prints the message, this is pretty cool. Now, in order to go from this, to Rust. Have you to do this tricky thing which is called jumping into long mode. What we were just writing we were in 32 bit. Without having to do quite a bit of hoop jumping, you're going to want to be in 64 bit mode. To actual how to jump into long mode would be way to long to show next year. Next year F someone wants to show, how to jump into long mode, thwack be a 30-minute talk. It's not that it's hard. It's really tedious. You have to create this table and shifting a bunch of things over. It's like reorganizing. But I do think what could be interesting is to take that assembly and refactor it, using Rust so we could now have a hello world from our rust program. And so we can jump back in and I'll click this. And I'll go into hello Rust. So sorry. And similarly, we have like, well, I'll clear this here. We have something that looks relatively similar to what we had before. We do have a bunch of stuff that jumps us into long mode, which we haven't extracted away.

But what we can see is if we hop into our lib do the s. This is printing hello world for us. So let's walk through what this code is actually doing. I should put some numbers in there for us. I have my K name. Inside what, I'm able to do, I'm able to grab the characters as bites by putting the B before hello world. So this is the many I'm going to be printing right here and then I define the color I want to use here, using 1 and F. There's actually a whole bunch of different colors can you use. That I can quickly show. These are the color option that is we have. Actually, a pretty good set. So we can play with those in a second. But then what I do, I create a mutable array, and I just automatically fill that entire array with what I want the color to be. And the length of that array needs to be double the size of my message because for each letter what I need to say is the foreground color, the background color, and the two-character code for what the letter S. once I create that array, then what I do, Iityer 8 through it, and for every other in that array, I replace the color code with the character code that I would like. Then finally, I create a buffer pointer, and I set that to the message. And that many is an array with alternating color and character codes. That is unsafe because we are just writing to something in memory. And that's extremely dangerous. Don't recommend doing it. The computer doesn't know how to break at this point. But it's definitely not something it would let you do. If it knew, it would tell you, definitely don't do this.



Finally at the end, we have this loop here. We don't want it to just immediately shut off. We want it to stay up. And so F we take a look here. Make run and we can see tait says hello world here employed now, we can change this significantly easier in the Rusts code. I don't need a cheat sheet ton what the characters are. Instead, I can go to my passage and change it to say hello RustFest. Whoever thought I would be doing something -- I feel like I'm doing a little CSS in Rust, which is pretty strange. And I'm actually a big fan of the bright blue color. It looks more like the logo. So I am going to set that instead. So then I can shave that. Hop in here. And oh. the demo gods are not a fan of me. Let's take a look what the heck happened. Didn't I actual about the errors you get in doing this? It's very fun. All right. Oh. right. Excellent. I love teaching want it's like pair withing 200 people. Because that's always fun. So the character, so what's interesting is that if you make the array too big T prints like these cute triangle bus turns out F. make the array too small T transfers a lot horrible text in your editor, when you're giving a talk in front of a whole bunch of people. So since you're all paying so much attention. What should the length with.



So we need it to be double. Double the length here. With we'll check do you want say, 42. We'll say make run. There we go. Yay. Ooh.



[Laughter]



That's fun. This actually plays perfectly into the whole point. Doing this is just something that's like, a fun exploration, not cute triangles this time, we have got some F's. That's cool. Yay. All right. So what just happened is this a lot things, include something whole area code mistakes. Fundamentally, what I was doing is creating this big array and filling it up with colors, and ultimately, I would put letters in there and I put that as a piece of data, and I assigned it to the pointer and that's what made it print to the screen. Now, something I would love to do is in that room where I'm keeping everything open, that's no reason I can't gist print tons of different things to different parts of the screen, you could have annex plosion of RustFest all over screen. You can crash your computer doing that, but it might be really fun any way. I was told this was way too complicated of a way of trying to do this. If I really wanted to demonstrate T instead of doing this whole loop shenanigans, I should just have written it out one by one the way I did it in the assemble least I don't really care. It's like, super fun to write and joy I felt whennic get N incredibly, at least what I believed, complicated set of build tools to finally print some tiny word to the screen. I was like, okay. This is really, really fun.



So I kind of want to leave you all with this many which is that this is from Leslie Lamp owe rt. He wrote a presentation called "Writing for Programmers" and this cartoons, "writing nature's way of letting you know how sloppy your thinking is." and I've been in my talks before, kind of reappropriating this, to teaching is nature's way of letting you know how sloppy your understanding is. And if anyone here has ever been a teacher, teachers in the room, not enough. Let that be the lesson if anything. If you ever want to know how little you know about something, try and explain thank you to somebody. And you'll be surprised. Beginners ask extremely difficult questions that are very hard to answer sometimes. So what I want to say is go write some irresponsible code. Write a tiny operating system that does something it is or could have and he go teach somebody else to do the same thing. You're probably going to end up learn seeing much more, just from that exploration and teaching experience alone, than following any sort of terribly structured tutorial. And even though the RustFest tutorial are good, you should stray from that and do some super goofy things. Intermesos has gotten you out of this kind of how to get started part. So intermesos is ready for people tow take a look at this, and extend it to Rust Bridge. It's already started for you to have RustFest connect to T. it's only nine months old, which is an awkward amount of time. But any way, it's interesting. We have 12 contributors. 233 commits and 444 GitHub stars for those who care about GitHub stars. There's only 12 contributors but there should be more. It's a very extensible thing. Can you build out your own little things on it and they can all work together.



I also want to centers the fact you don't have to contribute code to contribute to intermesosF. take a look at the book, which is the comp pannian to the Colonel's code base, we have 47 contributors with around the same number of commits. Not as many GitHub stars. But that's because GitHub fan boys are not really into books. We want to contribute into intermesos and doesn't matter who you are. We think you're really great and there's a very good chance have you something to contribute. If you failed to comply with what the general people think a real OS developer should be, yeah, you will look silly but that's like a super good thing, I think. So I can operate a system and so can you. Thanks so much.



[Applause].



>> RYANN: Thank you very much, Ashley. So we have another talk coming up. This is by Stephan Hugel, who will tackets about coordinate system transforms and FFIin Rust. This is his first talk about programming so I think it's going to be a good one. What do you think all right. We're going to get started.



>> STEPHAN HUGEL: So sorry about this, everyone. (Pause).

Yes, okay. I think it's working. Okay. Hello, everyone. It's lovely to be here. As Ryan said, this is my first-ever talk about programming, and you are my first-ever actual real develop audience and so try to go easy on me.

-

[Applause].



>> STEPHAN HUGEL: And so I'm just going to start off with a little bit about me. I'm a fourth-year Ph.D. student. I should not be here. I should be writing somewhere. I mostly work on something called smart cities, which is a terrible concept about making cities better with technology. I'm sort of interesting about write birthday history and policy that shapes them, the future and I'm note a programmer. Programming is not my job. I have an English degree. Do I data analysis and visualization as a kind of productive procrastination because of where I work. I work play lap and everyone I work with is a physics Ph.D. or an architect. So you get sucked into things by virtue of being there. I work on Python, Matplotlib, and I make a lot of maps, and this is the cycle analysis in London and some very basics special analysis. More lovely Data Viz and this is a prom, a colleague, this is building the London as tweets arrive from those buildings. So that problems is the thing that actually, that's kind of the reason I'm here today. And I suppose, before I say anything else, I should say, I planned to transcribe my slides into German, but unfortunately ...



[Laughter]



I'm really, really sorry. I know. I probably found that so much funnier than any of you. Okay. So, why Rust? I came to Rust by a series of weird coincidences. I had a friend that worked at Mozilla. And he tweeted about it, and it in a interstated way and this new thing called Rust, it's going to be really great and that was 5 years ago, the day Rust appeared, when it was, you know, unrecognizable to what it is today. I lookedda at it, didn't understand anything about it and I've gone on with my life until last year. So last year I went on holiday, it was also very boring. It was also great. And I thought, I'll have a look at this and see what it looks like. And it looked wonderful, obviously, I don't need to sell you on it. You're here. And so when I came back thirty one. I thought, okay. What is the best way to teach yourself anything pick something you actually want to do and work on it. As I said, one of the things I do is work with maps a lot. We're going to find out about those in a second. And there's really an excellent tool for converting. It's called PROJ.4. And it's been around since the 80's. The first realty + was 90 19New Mexico it's really high quality library, really well-mained and there's a python wrapper which is really fast. It's wonderful. So I decided, can I write something that's as fast because Rust is excellent. Something can you easily achieve. And I was very wrong. But not to worry. Okay. So I'm going to just briefly, talk about coordinate reference systems and so a coordinate reference system is a way of describing location on the planet Earth. They have two components. They have got a datum and the actual coordinate system. The datum describes how the reference is related to the physical Earth. So you've got a position of the recently, a scale factor and a Geoid. Which is this, it's kind of an idealized representation of the Earth. And coordinate system describes how the coordinates are expressed. They can be expressed in Cartesian coordinates. So have you Lambda u and u. And projected coordinates in transes verse -- and so the big reference system that is used everywhere is WGS 84. Everyone uselesses it for everything now. Datum is a point of the center of the Earth want that's where all its coordinates are measured from. And they have reckoned they have got it correct to within one meter. I use the WGS 84Ellipsoid. It's the only reliable way to do T. it's designed to be Globally consis within one meter. It covers the entire Earth. And can give you an accurate position. GPS can't, but the system, mathematically can. There's an off shoot, ETRS 89. It's mostly used for surveying in Europe.



[Laughter]



There's a historical reason for this. And so the U.K. uses something called "The National Grid" and use coordinates OSGB36. The 36 comes from the year that someone first invented it, so there was no GBS36.

So the national "Gridiron Gang" is used on UK maps and shaped files what suicided for making maps.



It's not actually Airy, the ellipseid here. It's called an Airyellipsoid. It's named after this incredible math my metations,.

So WGBS is great. Malicious the sea level more accurately. Which is agreement you have an Ecoordinate and an N coordinate. In order to transform between EG WGBS34 and OSGB36. You need three things. The data can differ in three ways. The position of the origin can differ. The orientation of the coordinate axes can differ and size and shape of the reference ellipsoid can deliver and thus, we're not going to dwell on T. can you avoid the trick iest one. If you convert all of your coordinates to 3D Cartesian coordinates and it's reasonably forward straightforward to do this mathematically. There's a link to the equation at the end you need 3 parameters to describe a 3D translation. Three parameters to describe the 3D rotation between the coordinations of the coordinate axes and you also need a scale factor. The whole thing can be bundled up into a linear formula that looks like this. And so if you imagine that here, A, X1, this is your X can coordinate. This is your Y coordinate and altitude we're not going to worry about that at all. So can you basically plug your 6, your 7 values in here. And do some fairly straightforward. Matrix algebra, and you're done. This is the last one of these, by the way, and that slide is not supposed to go there. And I'm going to give this talk at the flat Earth society next week.

[Laughter]

[Applause].



It's going to be next week is going to be much, much shorter as can you imagine. Okay. Any way, the thing to note here, essentially, the whole coordinate transforms to one piece of linear algebra, with seven terms, it's quite straightforward and you're kind of done am the problem S when you carry out that conversion, you introduce error into your coordinates and it can be up to three meters a coordinate that you got off your mobile phone will only guarantee to be abrate within 15-meters so it's no big deal. And if you happen to be using differential GPS. You see them on both. It's like a large professional GPS. You can get all the way down to 10-centimeters, which is really good, it's also not good for surveying. In the U.K. usurp vague carried out, using the GBS36 system. So they need aid way to very, very accurately, transform within WGS34 and OSGB36. And they have dreamed up a transform that is accurate between 1.1-millimeters, which is more accuracy than you need B. it's good enough. Up in the last week, there was only one. OST02. And as of last one, they announced a new one, OSTN 15.



These are so-called, riber sheet transforms which means they can operate in 3 dimensions. Can you have a longitude shift, latitude shift and a height shift. Essentially, what it is. It's a bilinear transformation, using a grid shift. So have you huge amount of the physical measurements of how you correct like, the wrong inaccurate result of your matrix algebra and that gives you the correct coordinate. Last week, [indiscernible] was 15. Which works the same way. But it's accurate due to the measurements. So how does the transform work? You go from W SH to -- have you error in your transformation. You get your grid shift parameters for the kilometer grid you happen to be in. Then you [indiscernible] your turblation, and that give us you your precise card nates and add those on to your [indiscernible] coordinates. And you have accord fates. So on to the actual Rust. I managed to write the initial initial conversion in Rust on my own. It's literally, a set of transformations. Can you do it in any programming language. You can do in paper. But I have no idea how FFI works. Stack over flow. Hello, I want to know how I can transform, you know, an array of point by leads. I want to interface, please. I got this like, incredibly thorough and wonderful succinct answer. I don't remember but they're incredible and thank you if you get the audience to remember this. So essentially, what you got is, you've got a C compatible instruct called array. It's got the data, and it's got the the number of values and then you've got a float -- and we have got something that converts incoming FFI values into a slice. And then, we have also something that converts going factors of transform values back into a void pointer. So that's back and now, we have got a function to drop this. So you've got an incoming transformation ad going, and dropping again. That's how do you FFI in Rust.



So the implementation of the actual transform was really easy. Nothing Rust-specific about it so I'm not going to dwell on it and there's a coordinates check to make sure you haven't given it a longitude and latitude outside of the transformation. This transformation only works for the U.K. If you use value that is way offshore, it won't work right. So have you to have that in the chain. And the look-up was fairly straightforward at the time. I decided if anything went wrong, rather than trying to deal with T I'd just return a man value. They're easy to check for F. you give the transform like, 10 coordinates and coordinate number 7, it's easy to check for. So I just kind of left it. Another thing I found, while I was doing it. This is like this wonderful crate called terrible lent and for those of us who are not mathematically inclined, obviously when you're doing felting point operations, it's easy to get a little wrong. And multiplying like a tiny value by large value. Suddenly, nothing works anymore. So the University of Washington wrote this, it's a tanned-alone tool and one I rather excellently posted and the quiet version. And it will look at your code, and tell look at any floating point operations in your code that are potentially unstable and it will suggest improvements. And it's really, really useful because it's quick. You have to switch it's okay. It's kind of like a floating [indiscernible]



So then the next step is integrating the actual accurate adjustments. There are 876,000 and each adjustment is three point float values. [indiscernible] value and other altitude value which we don't care about. It exists. At the time, they're in sequel I.D. so that was not going to be quick enough because you know, if you need convert a million values, you can't be doing a million calls. I mean, you can and it's not super slow. But it's also not as fast as I wanted. After stack over flow. Excellent. So for those I don't know, PHF give ace compile time static maps. It's got a really, really easy example, which I copied word for word, basically. And there is a binding for us. [indiscernible] QLS and I tried to build. It took like two thundershowers build on this thing and took another two hours to compile. Move all that stuff into a crate and never worry about it again. Test once and compile quickly. So the O ST02PF equation is available on caring O. if case anyone need T. it's good to know tait's there. Back to my primary concern here, I want this to be fast. And so this would being like, July or August last year accident, I guess. There was no sign of cross [indiscernible] at this point.



I managed over a space of days, write this horrendously all of function, which takes in two slices, combines them into a vector thens yes, a vector -- I'm sorry. I'm like, reliving things dilast year and it's really uncomfortable. And it goes on and on and on. And this is the non-scope thread so you've got this thing here. You've got to move and reallocate. You're finally getting to happen your element here so needless to say, this is not great. It worked. Don't get me wrong. This is like, you write the thing, and if the compiler doesn't crash, it's probably working. I was like, extremely proud of myself. But it just is not great. We have hire coded the number of threads. Casting back and forth between floats. And then you're calling to own on the thing and it's allocating again and there's obstruction code in there. I know. I know. It was a long time ago. And someone read T. why are you [indiscernible]. Just like, forego all this. That's good advice. And I put my Rust coat away, and went and tried finish my Ph.D. for okay 6 months. Then I had some time over Christmas. Okay. Let's see if we can do better. In ababstract sort of way, we have a sequence of values. Eastern or northern values the length of sequence isn't going to change, we're just transforming them. And type of values isn't going to change. I read this back, and it says, please carry out all operations until the precision floating point. It's F64N -- 64 end, but that's fine. So the solution, we just use mutable slices and also, some time has past. Threading libraries exist. And also, we can be generic in terms of our threat dysfunction. So we can write a function that exempts, two sequences of mutually barrowed 64 values and we can pass in a function that implements copy traits. Just keeps the compiler happy. I figured this out, by the way, leaving them out then compiling. No, you need to have a could you please. I was like, okay. Cool. But copying. No, you need to have send.



So you put those two traits in your function definition, use it the sequences together. If you imagine you've got sequence of longitudes and latitudes and really, what you want is kind of one of each to give you a point, and so you've got to zip them together. Split the rut into mute I can't believe chunks so&those chunks retain actual coordinates. For each chunk, apply the conversion funk, and then you're done. This has a nice slide effect. I was able to make the library, much cleaner. So you have a function for each type of conversion. So WGS84, to OSGP36. Come back again. And then you can define an FFI funk for each of the top level and move everything into his own maddual. We have got conversions, which is where all the boring mats are. FFI module and then we have got Lib where the top level generics live. And we have got utilities, other boring stuff. So interlude. It took me a long time to figure out the chunks and chunks trend slices. Tack me days. I know I had to do this. This is what it looked like when I was writing down in my notebook. This is totally wrong. What do you get back when you called churches. Low and behold, it was a slice.



This predictive clarity and momentum P.R. which altered two words and it got instantly emerged. So thank you, Steve F you're here somewhere. So on to the fancy threat of function. Take 2. Now, we have got a lifetime specifyer. We'll talk about that in a second. We have got our function here. I'm going to give you back the result. And implement copy. And then, I work at how many threads can I spawn, based on how many CPU's there are. There's really quite useful CPU's. And then, I spawn like, an appropriate number of threads apply my conversion funk here F. I get back an okay. And you take the value, and you take it into now. That's pretty much it. There's a little bit of right away drift. But it's not too bad. And then send. This is rayon. It's considerably similar. Instead of spawns and scopes, you've literally, got part of muge. So obviously, because I'm curious. Reneed a lifetime specifyer. I'm talking about as if I know what's going on.

So I started off, using a separate one for each slice. But actually, you can just use one. Reading signatures, so, so -ful. I've got a link to it at the end for those who might want to, you know, feel inspired. Any way, okay. So I then compared the speed of cross beam and rail. So first of all, so the purple D.O.T.s are at this ancient two core here. And on the left, you've got crossing and on the right you've got rayon. So essentially, what happens is, no threads. You know, two threads, which is the number of CPU's. You've got an instant and drop in the time it takes. What's going on. It says I've got 19% battery left. As soon always turn on threading, essentially and get a huge speed increase. And it stays pretty much constant, then starts to get a little quicker as you add loads of threads. This is the fastest one here, which is like, one per CPU. And well, that didn't work. Oh, no. Talk among yourselves all right. Where are we. I'm like, lost on my last talk. This is disastrous. Okay. You have domes like this, sometimes. The reality is so much worse. Measuring speed. When you're using cross beam, what you note is, using the number of CPU's on your system, number of threads is what will give you the quickest run. Here it is on two on a two-CPU system and here, on an 8-CPU system. I don't know what the error bars are so gigantic on the CPU-2 system. Anyway, they're much smaller here much these are the error bars. So adding threads, really does nothing, then it starts to degrade performance ever so slightly as you have loads and loads. It essentially gets it right first time, because it is embarrassing parallel. And it just science equally to everything and does everything. Then if you start tinkering with the way, you start getting ever so slightly worse performs and that's on both systems. So that was interesting. I have no idea why I took those. I decided, which is better and turns out. It makes no difference in the end for this.



Okay. So next thing I tried tow build python builds, and my python wheel is just this piece of code, which is siphon code. I don't know whether any of you use siphon and I don't want to bad mouth things because we're positive people here. Siphon just assumes you know HedraC. I had like a lot of help in making worth and it works. Converts them to memory views. Sundays them into the FFIfunction. And then copies them back out into URA's, it's pretty compact. And it worked perfectly. So I don't worry about it too much. And in order to actually make this usable on three major platforms. I used the Rust everywhere, which give us you Travis and scrips for everything. So if your approach approach is run some tests. If the condition is true. Publish them F do you want integrate bits of travel car coverage, you can do that.



I first of ology, built my Rust dynamic libraries on each platform. And push a tag, you end up with artifact if your releases. I've got artifacts for 64OSX and for Linux and then for windows, 62 bit and 32 bit and it works almost out of the box instantly, when Trava is not there. So difficulties. You have to understand what link or arguments. I just spent two days. What is this? And then eventually, it worked. And began, I just forgot about T. I know that's really all of, but you know, sometimes you just, you have to deal deal with the world as you find T. just a note on building Linux on python and there's an agreed-standard called Linux 1. The Linux build for compatible. Can you get it as a docker image. And you will have to build your dynamic libraries inside docker image, if you want them to be Linux compatible and that is definitely something you do want to do. Project for windows another autos not available for python 3.5, it works really well for everything else. Scientific computing community. So they do a lot stuff with num pie and there's a thing called multi build, that will allow to you build for a variety with micro S versions.



So the real reason for here.

[Laughter]



Who knows what's going to happen next. Apparent he, I have some juice left in this thing. So in order to bench mark. Convert, I generated 10 million round of points within the boundary. I'm going to convert them to OSGB36. And the way diit was, C4 which is the computerized optimized systems. You were in the same bench mark program for each of three configurations. Now, three configurations are, Rust dynamic library and C-types, which is an easy way of interfacing with dynamic library.



So this is the X instance so here we're talking about 7 seconds B you only 9 seconds. So we're at 58% slower and 24% slower. But then, the two by X large instance, even using C types, which is the sort of toy version. We're at 6.5% faster and then, we have got a 30% decrease, instantly and on the 16 processing machine, we're down to 30% slow or C-types and 60% slower -- or faster. Oh, my God. Faster, it's so much faster when I do it. 60% speed decrease and finally, on gigantic, processor, you're down do -73%. So it's so much faster, the more processing you have. So I'm basically done. I'm just going to talk very briefly about, special computing and there is an organization, it's in active development. There's a few of us. We're basically aiming to provide geo spatial primitives. We have got like point types. Line stream types. Pole gone types and multiple versions of that, and we have distance algorithms going. We have [indiscernible] algorithms going. There are Rust libraries for reading Jason, WP. Polelip line, they're all stable and very few people working and I know that geo developers are difficult. But if you think you might like to be one or if you're just good at maps if a way that I'm not, definitely find us. . This talk is all true, but it's also mistitled and it's really asking a lot questions and getting incredible answers. As you know, some parts are really, really difficult, especially when you're starting out. And the community is so helpful. I know it's getting better every day. And it's not just helpfulness. That community is so supportive and it's so encouraging. Loads of programming which communities are helpful. But sometimes, there is like, if not contempt, there's an assumption that you will just get on with it on your own and Rust is not like that.

So I watch you helping people and I watch you being patient and I watch you being kind to one another. When people sexual harassment very, very simple, starting out. And it's very, very inspiring and it's what's what keeps me and I should just be writing normal words. So thank you.

[Applause].





RYAN: Martin will be giving next talk. Apparently, he was looking at the gobble maps URL and sought coordinate he is got from that, and it was tow a so specific of numbers, something like, 10, 15 decimal places. 13 decimal places. It would of course so accurate to the nanometer.

>> MARTIN HELLSPONG: 10 nanometers close enough.

>> RYAN:  I don't think we need talevel of accuracy, but it's go g to know we have it. Just in case. And without further ado, here's Martin.



[Applause].



>> MARTIN HELLSPONG: So I got some water and I accidentally got sparkling water, which isn't a good idea before I talk. But I was so nervous, it's not sparkling anymore. So I think it's good. Oh. I have my password. It's just star, star, star, star. Really, I forgot this one. Oh. it works. Okay. So my name is Martin Hellspong. I work at factor 10. I'm a software initial there and we are based in Sweden and it's awesome to be here at Rustment really? It's there it's not there? I also didn't start the time recording, right? So let's do that. (Pause).



I'm still not there? Yes. So it's awesome to be at RustFest and I'm here to talk about QuickCheck, which is a test method that is under appreciated, I think. And the reason is that it helps you find bugs that traditional testing often don't find. And there have been case studies, showing that you find more bugs with less effort per bug, using QuickCheck. And that's a nice promise fur. And traditional testing it works by very fine expected behavior and perhaps you poke around some of the expected edge cases. I haven't changed my slide. So I'm where I'm -- both slides. It's just that I have a long intro and setting you up for all kinds of failure. Any way, and now, you lost me. The reason for this is that this isn't optimal because you write your own tests, and you won't surprise yourself. But the randomness will actually surprise you and your code. So that's why QuickCheck uses randomness to generate hundreds of thousands or like, any number of test cases you want, according to a specification, and randomness gives, the power to give varied test cases. As an example, there was a bug file against Google's level DB. They hadn't -- Google hadn't found it with traditional. But that's because it needed a sequence of 17API calls to trigger the consistency part. And quick check found this by someone writing a test for quick check that, explored and looked for inconsistencies and see randomness. We can all agree, no one writes a standard unit test, at least that long. So my ambition with this talk is to get you excited about using this if your problems and I'm not going to be very Rust-specific so most of what I'm saying is applicable to quick check in randomized testing in general. You should be able to take something out of your projects. Okay. QuickCheck. There's variance able from most almosts, now, but it originated in the research community about 1999. Worked from [indiscernible] and John Hughes, and John use Hughes is author of functioning paper.



You need to make a testable statement about your code. For example, say that they're written in absolutely amazing summation function. And can you make a statement about that, say something like, my summation function makes a list of integers and returns positive integer always. And the traditional test method, it's like you're an intern. You and your co-worker, sounds like it's working. Because I used it in one test and it worked. But QuickCheck is more like your know-it-all co-worker. But he won't take your word for T. we have run hundreds of test cases to see if your statement actually works: So it looks like the significant of your statement a lot of test cases, try to find a counter example. If it does, or if it doesn't, and if it does -- it has a test case used to prove you wrong. And this is how continued look in code. This summation function. Just takes list of integer and it's so awesome I didn't even include the limitation. Then you have your statement, which is something like a function that's posted. Takes the list of numbers and give us you the Boolean.



Succeeds, returns true all the time. In this case, probably what will happen is it will say something lib was posted, it failed, when given the example, the example is the list of the number minus 1. Negative number, obviously, it wouldn't be positive. So that's QuickCheck helping you find discrepancies between your code and standpoint. Perhaps in this characters summation function should have onsite integers or your assumption how it works, you should find a different statement.



How does it know how to generate test cases? Well, for primitives these funks are built in. Counter example, QuickCheck does something called shrinking to minimize the test case. You can also provide a custom type. But that's seldom necessary. The possibility is there. QuickCheck now introduces randomness into your builds. And people will say stuff like, we don't want unstable tests. You must know who broke the bill. What change did they do to make it fail. What if it poses QA and fails the release without any changes. I mean, that's valid criticisms. Some processes doesn't handal randomness and on the level of individual developer, I mean, you do a big fix ands in not fixed. Or is it just because of failure case wasn't generated. Or you ad a test failure. Does a failure case happen to be [indiscernible]. However, in practices, often, much more stable than you would think when you heard randomness. It's not like it flips flops. It works because you generate hundreds of test cases. If you have some case that's only generated once in every 200 test cases, 100, perhaps it flops and flips between. But otherwise, it's mostly in my experience, they always at the same time they are programmatic. But we must remember, the correct decisions now we introduce untable tests. An unstable test is something with the same input gets two different ruts. You don't know Y. but the unlikely case, it happens and then you get the counter example. That's when given this, it always return this is failure. So you need to take good care for example, and you can produce a unit test.



You can also tweak a generator, if you have generator for your type. You can tweak that to generate cases more often. On the process level, we could look at fixing the seat to the random number generator. However, that trades test coverage for stability, which is not perhaps a good trade-off. Depends on if you want to find box or you want your build to always work. You can always give up. You don't run a grid check test. Perhaps you need traditional test and you could do [indiscernible] running, to see if you could flush out some bugs.



There's a tradeoff you need to make. So now, we can look at how I use grid check. So in my project, it's kind of a micro control. I really like how the previous talks have geared into this. It's very much helpful to have a couple of concepts explained. It's kind of controlled projects. Do I it on my experimental time. So I get paid by but the company doesn't. But think going that, it wasn't that funny to, not that exciting to do. I want to do something more outrageous. I probably need to make a simulated word, with a space shape, with a simulated micro controller, and then I knew what kind I wanted and see if you can guess which one it is. This is the classic version of the Macintosh. And commodore A minga 500. This was the first so for those stack of reasons, I chose the processor, running all these few manslaughter. The Motorola 68,000. And also 40 years old, the computers. Or the processor, rather. So it's possible to emulate it. Something like 18 megahertz.



So now in reality, we have a simulated micro controller problems. 8,000 CPU which is often called M68K. I took an existing C library, running in the main emulators. And I report that to RustFest and I decided to do this, rather recklessly, as project write up. And it's called R68K. And it's off of GitHub. It isn't fully functional yet, but it's useful. For me. If you look at regulator what you need to test this.

It's only 58 instructions. So possibly, can you just write 56 units. However, this doesn't really work because it's annex plosion ever instructions, data sites, registers, and you can release for one single code and there's 64,000 value of up codes, and about 11,000 I think its has done transition, anyway, so I knew then, I needed quick check. I couldn't possibly write enough tests. So how diuse it? I basically made a statement. There's two CPU's. They should behave Identically. And by identically. Giving random initial states. Execute one instruction ethical. And it's very fine state is shaping the content of registers and memory, as well as old memory access are correct size and alignment and what not.



Then I thought, QuickCheck, just go ahead and approve me on this. And it did, repeatedly. Remorsesly. Lee and ultimately helpful. I ended up with 1,600 QuickCheck tests. One test is testing combination of register and covers all the possible cases. Hundreds of trials each. Running all the tests, is something like three hours, 45 minutes. So single threaded so I can't run parallel. I've used gnu parallel to run cargo in parallel, the tests. It's one test per instance, I ended up doing 16PR's. Elements like cycle counts. How many cycles it took. And I had a single complex statement about the identical behavior. You don't need to have a perfect comparison. This statement was much simply in the beginning, it was still very, very useful to get something and as soon as you take the statement and improve it. It will improve this test. Now to run a more thorough comparison. I'm very happy to say, verified with QuickCheck. I'm basically, 100% sure. And if you for all the instructions. I still have work to do with exceptions and stuff, still provides me a use value. Let's look at the bigger picture. Not talking about my project anymore. I could talk about this for hours but you'll have to catch me tomorrow. So we could here, take a look at a statement, what is the problem of the statement. It's hard to, when you start using QuickCheck, it's hard to come up with different kind of staples. You normally, write the unit test F. input 42, I should get this back. But saying for any number that hold, it's not that useful. So now, I get to the fact part and fact part is just saying something about your code. There's basically F I back up a little bit, there's three different things about statements. Effectses, inverse functions, and there's compare WGS a known good one. Facts will already -- we have already seen. Summation function. Inverse is something like encode, decode. You encrypt something and then you then decrypt it. It should return the same value. If you compares pare something with a non-good, one thing you can use the verged of your code. If you have an implication, and it had a very nice indication of something, it was slow, but it worked. Then if you need to do a performance, you can have your QuickCheck round against your standard non-optimized case and compare it against the optimized case. With kacheing. -- cacheing.



The guy drove an idealistic model of the database, with capabilities and ran that together with level, and check that they matched all the time. The model is much simpler. It could be a memory carried. You don't need to make all the guarantees. You can also take existing code. That's the third one. And one of them is third party which I was using. You can have the old verged of your code. If you have version one that does something interesting and you want to do a reimplementation of that and you want it to be as good. You can compare verged 1 and version 2. So I have skipped one thing. What happens if you have irrelevant cases, you want to discard those when you're testing. There's also an example of an inverse assemble. Thank you for mentioning those. Now, have you to return a test result. What you do S you have a function. This assemble, San off code, which is basically, 16 bits. If you disassemble T you should have a -- not all codes are valued. If it is not valued, it'll return an error. Don't bother doing this test now because it's not valued because I can't assemble but if it happens to be valued, I get some successly text. Being be something like are like, [indiscernible] to 3, to 2 points.



In code we test if you assemble this text, do you get the same code. You started with, and you create the test result from that. And this means that test all the places where disassemble works. Assemble should work.



I also want to mention, other place where is QuickCheck is used. I think it was 107. They all use QuickCheck. Ether tools, test fact about function u functions. And the wide range, talking about Rust at all, ERICSSON is using to find race conscience in the database. In the 4B based stations. They tested integration. Buy stuff from supplies and put it in their cars. They found box in there communication and also found inconsistencies in there of the source.



I have one last story. Level DB1. It was even more absurd than the one I said. There's a talk about this. Land of jam, 1013. A guy called John Orfton. Found the 7th instant sequence that failed. Google, provide aid fix. He ran the same QuickCheck test. Now after a cowl of minutes, found a 33 step sequence that reduces the same of inconsistency, and I think you can agree this is almost impossible to write the unitests, that would catch something like that. So the wake away is, you won't surprise yourself. Randomness will. Stop worrying and learn to love the it. Thank you very much.



[Applause].



RYAN: Thank you, Martin. Next, we have a tradition of cake and coffee, that will last for roughly, between minutes, I believe Soros. Maybe a little bit longer. And then we will come back with more talks. So enjoy your break.



[Break Taken]



RYAN: Attention, everyone, we will be starting shortly, finish up your coffee and finish up your cakes and your conversations. We will be starting in just one machine, so please, make your way back to your seats. Thank you very much.

All right, welcome back. Has everyone had enough cake and coffee in their system now? Next up, someone that hails from Dayton, Ohio, and now, here in Berlin. William Light will be talking and let's give him a very warm welcome.



[Applause].



>> WILLIAM LIGHT: So about two hours ago, hi to patch my presentation software because it wasn't working. We're going to hope everything holding it. My name is will. My background is ins C. Lo level stuff. You probably don't know anything about me but if you do, it's because of this thing right here. This is a monup grid 28. I've been developing and maintaining the drivers for this for the past 5 years. We're talking about drivers today. Normally, when people been drivers, they think about drivers and the driver handles low level details of hardware and it hosts up to a higher level of abstraction. Presenting some sort of protocol by thes from some source. And then translates to into a high level inner face a lot of time keyboard or mouse will send some bites and kernel will interpret it and output it on the input subsystem if we're talking about Linux. The benefit here, of course is that you can abstract away some of the underlying transport. US BS2 track pad. Whatever. But drivers don't have to exist in the cerne. We're going took talking about drivers and unit space. Still doing rough lite same thing, but since we're if user space, we don't have to worry about causing kernel panics. We don't have to worry about breaking the system if we happen to hit a South East g fault which we won't be doing today. The performance is absolutely lower. We can't dip in and do real-time stuff. We need to move a lot of audio, for example, that's kind of my background. That's going to be a little more difficult tow D. but we don't have quite as steep a leadership curve. So we're going to be writation user space driver for this thing right here. A native instruments machine micro mark 2. It has these 16 pressure-sensitive Pats here for like, finger drumming, tough like that.

A bunch of buttons, screen, everything lights up. So this is kind of purpose-built hardware. Service shift solve software, and I don't have any cuter that is do windos or MAC. So I wanted to figure our how to make it work. First we're going to cover the table of contents, materially. We're going to figure out how to reverse fortunately this thing. We're going to write the driver and then we're going to kind of revisit, and see how far we have come and how much we have grown as people. Let's touch on the concept of USB interface devices. USB is a fairly complex protocol. We're just moving bites around. So human interface devices. Vee communicate via reports just a message. I snagged this one from a USB mouse. So the first bite is called the report number, basically, just a message I.D. so in the case of mice, report number 0 is motion. Report number one is left button then it goes from there. And the rest are just bites. So human interface devices class specify what each of these bites are for much so in the caves bite. X displacement, Y displatement and I don't know what the fourth one is for. Linux cerne doesn't seem to know either. So we don't have to care about that. USB HID devices can be raw. So I'm really rushing through this right now. I thought this was going to take longer beautiful okay. We're on a behind California. Get us back on track. So a number of different ways we can reverse engineer T. there's the easy but complete way. We can get slightly Dodgy. Look at way professionals do it and look at kind of a really fun hat I didn't know you could do. So the easy way to do this, is we're going to create a little Rust Bridge program that, just opens the device and dumps data from it and then we're going to fidel around with the device and see what device comes out. We're going on use NIX want this is low level any way. We're going to read bites off the report. The rest of the bites, and then so we're going to have some very bountiful output here because that is the wrong monitor. So here's what our device lookses like when we open tup. This caught me by surprise. You'll notice F we start pressing down whoa get some of these bites that start to change. And you now, as we go down the line. This has a whole bump of lights on on it. The method I use, which I don't necessarily recommend because I don't know how well hardware will deal with it. You throw as much data as you can. When I ran this, all the lights lit up. I was like, all right. Cool. So we're done here. And then, I literally, just put a sleep in, and I had it next to my computer. I would run T. when the lights came Oi'd stop it is there, and restart it and just narrow it down. I found out afterwards, during USB enumeration, HID devices are required to specify what respects they receive and how long the report S. that's note as much fun. So let's just do it this way. But if you remember, there's a screen here and we're not likely to figure out how to run that, just by throwing bites at it. So let's move on.

By citing more proper methods of reversing. Proper translates to expensive. This is USB1. This is USB2. And this is USB3. From what I understand, total phase, which makes the eagle. These are top of the line products and they're fantastic. But that, I'm not going to drop, you know, we only need this one. So we only need to drop 1400. I don't have that for a weekend project. This is like, 300. So, really what we need, we need a computer that communicates with a device, using the official software and we need some way of sniffing T. since we live in the future. We can run a computer inside of our computer, and man in the middle USB connection from there. So that's exactly what we're going to do. We're going to open up a windows VM virtual box and then we're anything to do this move. Linux is a Colonel interface that lets you tap each individual USB bus, using wire shark.

[Laughter]

I'm serious. I'm serious. I took these screen shots on Thursday. I just made a filter, I guess protection so we can make sure we have goat the right one. And let's go back and take a look at this. So this is what the button many looks like. Every time you press a button, it Sundays you a bit map with each button being one bit then it just communicates the whole state at one time. We can go and locate that. So here's USB if. Wire shark doesn't decode the HID pay load itself. But as you can see, 01, BOO6. It's ate a little different. O1B80 womp we have got the 84 there. I wassing to lipping a button on and off want we get the same one here. And then what we need is we need the response to this, lights up the button from the official software, and here, we have it. Then we have okay one and unfortunately, the light I want is obscured by this seam in the screen. But can you see, we have got that on and off. So let's just pretend that we have gone throughout rest of these steps and we have reconstructed the messages we need to know to the device and let's get on to the actual driver.

The inputs and outputs, we're going to be listening to a UDP socket. There's this open sound control protocol that's used for like, be spoke interfaces between multiI media software and hardware. Then the outputs are, we're going to send MIDI. Super old school communication between sequenceers and synthesizers, and then it just got used on computers because it was there. And we've been stuck with it every since. Output MIDIand output C. Quick not on OSC, it is absolutely resty looking but the serial formation is, it's really cool, it just kind of sucks as interprocess communication, which seems to be all that but anybody ever uses it for. You use what you have.



So let's start building the driver. Let's revisit, opening the devices. So we're hoping our HID device and using stock standard net UDP socket. And then we're going to dip into 96 and construct a pole loop. So this is one of my first things about doing this on Linux. In the beginning, I said shift a driver are f are that blinky box thing. That runs on MAC OS and Linux, it's so natural to wait on multiple types of file descripters, in the same pole call. So here, we're going to be pole polling over a raw HID device and raw UDCP socket. We're also going to construct a timer here, because we don't want to send LED responses to the device quite so fast. We end up kind of overloading it and things start to lag and it's not as much fun. Pretty straightforward. Pole-type loop here so can I leave it here and everything else is protocol-specific. But I thought that was going to take 5 minutes longer so I'll get into talking about buttons. There are a couple of alrhythms I stumbled on upon here. Since we have a bit map of buttons and we just need to know what's set and what's not in each button report. I have kind a look up array here trailing zeros, can I use that to skip through a bit field and find all of the 1's. If there are no 1's, if guff just got 0's in the bit field it becomes a no-opF. you ever need to cache the dirty state of a set, if you can stuff it into a bit field, you can trail 0's, find the 1, trailing 0 after the accident find the 1, trailing 0's, find the 1.



The pads are a little bit more complicated. We just get raw pressure value from the device. And even worse than that it's not debounced very L. I'm just going to start up the actual program I used here. Cool. So now, we have got the actual program. Can you kind of see it lighting up a little bit. If I shake it around a lot. And it's difficult to see if this light. If you shake it around. Can you see, these are very sense tive pads so we have to do some sort of filtering of the data, in order to work with it. When you think about this from a pliability perspective. As a finger programmer, trying to program beats. You're going to want to set a threshold. You obviously, don't want a step to trigger if you press it too lightly. And then you want a pretty decent pressure gradient, up to the maxxum that you're going to touch. And linear exponential. That's usually, configurable. So what I ended up doing and reason I've implemented it the way that I did. I wanted to make it so that if you pressed two faintly, you couldn't trigger a note by pressing layer. Even if you press too faintly, and you press harder, it still tracks that. So we end up with the threshold state and otherwise, we end up in the press the above threshold state and we send a mini-after touch, which is kind of inside of a note, can you vary the pressure up and down.



Let's see. That's just about that there. So future work. There's this screen on it and I figured out how to make it worth I ended up Dutching protocol. This picture is a die issue the program that's put on there is written in C. So yeah, bring it. Come on. Come on.

I'm good. I wanted to do this in Rust. But I wanted to have like a nice graphics APIfor doing that.

I looked at GFRX. So I couldn't find one that had a backing store. I could draw lines and accomplice stuff O. so I gave up and put it on the back burner. So I'll pick that up at some point. So some parting thoughts. There's actually, so, besides the low-level binding to the Linux mini-sequenceer interface. There's one block of unsafe code in this entire user space driver. Because I was too lazy, I just wanted to take this. If you remember when we saw that huge block of pressure values, they're little Indian U-16's so I'll treat 'em like T. too lazy. I know they're slice Friday all parts but Wyatt the time. So I kind of left this in. So something originally, I was using Amayo for this, I figured it would Abe good chance to get a feel for the Rust Bridge asynch landscape. When I upgrated and rewrote the API, I got an additional 15 to 25 seconds of latency, this could be a problem for these type of applications. 10 millisecond citizen maximum you can have for a person to consider the response to be action as being the same action. Beyond 10 milliseconds, you can perceive the delay. And really, you want close tore 5-7 milliseconds. I haven't measured how quickly the pad reports come in, but I've ballparked T but you know, one, to two, to three milliseconds. So having an additional 15 to 25 seconds of latency is kind of unacceptable. I reported the bug, they thought it was because of TCP node alay. I don't know, something to continue investigating I'm sure.



So I wanted to come back it this. Can I do a retrospent specksive of the code. The driver is called serial osque. It's actually a USB serial device, and outputs open sound control, kind of bidirectionally, and you write application that is consume and produce open sound control. So when I originally wrote this I used the low level, loop primitives for all the operative systems. I was using pole on Linux, collect on OS10. Wondering why didn't I just use poll on both. On Linux, you can't select on a USB serial device and on OS10, you can't pole on one. Welcome to cross platform low-level programming.



About a year and a half ago, I tried to factor this. And it worked fine on Linux and broke entirely on windows and OS10. And if you're going to be writing code at this level. I think that it pace off to actually know it is API's that you're sitting on top of. I went and took a look. Serial osqu is code -- most of the platform is windows, of course, the most special of all of the platforms. And then there's not actually a whole a lot code for Darwin and Linux. It just comes down to if the code breaks on an OS update or in somebody's special case, it's one thing to be able to go to MIOand, you you know, file a report and drill down. But if you're shipping production software, that kind of, that bug has to stop with you. Basically, I think much the hard part is not writing the code. The hard part is understanding the underlying API's and documentation can be sparse sometimes. I believe that is all that I have prepared want for ya'll.

[Applause].

So yeah, first talk. I think we may have time for questions for once. Do we if.

>> This is the first, I wasn't prepared for this.

Yes, we do have time for questions.

[Laughter]

[Applause].

I am recently on the job market. So looking for cool projects. Come see pee, I'll be around. Also, while I have you all here, there's a particular RFC, allows field and traits and values can we please have this? Can we please have this. Police. I bolted single inheritance on to C and don't want to olt Bolton it on to Rust as well.

Okay am cool. Questions now?

>> RYAN: We have time.

>> WILLIAM LIGHT: We have time.

>> AUDIENCE MEMBER: User space, except for easier development?



>> WILLIAM LIGHT: Well, so two reasons.  A, there was no real reason to do it in kernel space. There's a previous generation of this device, was not just -- so it was vepdor-specific entirely. It wasn't like a human interface device. It was vendor specific and I would have had to use lib USB. And that's his own special brand of hatred. That's in the Linux Colonel now, which is cool. But yeah. A, there was no real reason to do that and B, one of the things it is create a network socket so program consist communicate with it. I don't feel like loading a Colonel module should open up some user, and then have you to deal with, how do you set the port. For me, Colonel module shouldn't be opening up network ports. That speaks to their not being the right Colonel interface for that, I suppose. In the case of the mononly stuff. The reason yet user space is so we can standardize on one API across platforms. There's a port running. You you communicate with it that way. Can you run the same application on windows mac or Linux. So that's why user space. If that makes sense. Does that make sense? Okay . cool. Any other questions? are we set if 'sup, Tim? I'm chillin'. You know.



>> AUDIENCE MEMBER: Do you think Rust is a good language or environment for writing future sinsizeer drivers or pad drivers, and do you think it would be easy for someone to pick up a different brand of pad and start trying to write a driver for T. are we going to see a renaissance in Rust of these drivers?



>> WILLIAM LIGHT: L here's the thing.  It's been a while in the consumer interface, since I've seen a piece of input hardware, that's really vendor-specific and kind of locked down. Usually F you go out and buy a mouse or keyboard. You plug it in with your machine and it's going to work. As you get to more niche areas like production, they'll have these custom controller type things or 3D modeling, there's all of these really specific pieces of hardware and I think that people should be able to crack those open and do whatever they want to with them. Things really important. And that's why I had so much content dedicated to find a USB device and here's how can you figure out what it's doing. I would like for more people to do it in Rust, and that's why I'm giving talk here. While lib UV and MIO, Crone if this is necessarily their foreat a and if they should be dealing with this low-level thing. I know there's a Lib UV, Dev type of handle. But I think there's an Avenue here to maybe start building libraries, crates to, do this on a more cross platform base. I think there's an opportunity to open up some hardware. If that makes sense. Thank you. Pleasure to be here.

[Applause].



RYAN: Our next talk is about a topic that sometimes isn't talked about enough. We have had some deep diving in code. And that's agreement but there's something else we do a lot in our day-to-day life as programmers, and that's communicate. So our next talk by



Sharon Steed here. So give her a round of applause.



[Applause].



>> SHARON STEED: I'm sorry. It might take a couple seconds to connect.

(Pause).

So exciting when things work, eventually. Hi, everyone. This talks about communication, so the first thing that I'm going to tell you is that I stutter. Now, I stuttered for gosh, I think I was about three years old. So around this age. I know, I'm painfully adorable. It's okay. You can tell me.



[Laughter]



And stuttering has pretty much shaped the way they communicate ever since I was that person right there. Like I said, I began stuttering when I was around three years old I was talking to my parents about it and they said they weren't all that concerned because you know, tons of kids who are around three years old, stutter and they kind of grow out television by the time they're 5 or 6. And then I also had like, cousins who stuttered, my brother did, my parents did, and they all just kind of grew out of theirs, by the time they were around 17. And so you know, people just thought yeah, you know, this is a thing that is kind of happening right now, but it'll go away on its own and that will be the end of that. Well, I'm 32, and it's still here. So, I guess it's just kind of, you know, here to stay. So as a person who stutters, you kind of develop coping tools. So I did pretty much so many things, that I did. That were kind of odd work because of my stuttering. So I would try to conceal it I'd say things kind of I would try to just stay away from situations where I knew that I was going to have to talk to people. Because I was so terrified of stuttering I would change words because when you stutter, you are keenly aware of of the words that are going to give you some trouble. So before I would have to say the word, I would quickly think about a different word to say so I wouldn't stutter. And so I came to a point where I knew that stuttering and the ways I was coping it was pretty much taking over my personal life A well as my professional life and so I decided that I was going to try to face this fear of talking by pursuing, you know, just smaller opportunities, to speak in front of people. And I know that sounds insane, but I'm the type of person who, like if I'm afraid to swim, I'm just going to jump in the deepened and see what happens. Hopefully, I don't drown and see.



[Laughter]



And so when I begin pursuing public speaking, the views that I had, had of communication came pretty much drastically. So McKeown 6:12-01639 occasions supposed to be an act of incredible empathy. The problem is, it definitely isn't. To talk about communication, we have to kind of talk about conversations. So the way that we approach conversations is typically, pretty bad. That's you, and you come up with this cool, you know, thing that you want to tell people. So you have an idea. That's you. That's the thing you want to tell people, and you get really, like, pumped about this idea, right?



But you don't want to drag anything am but you think that this thing that you want to tell people it could have legs, right? So you're pretty excited about the thing that you want to share. So you think about the thing. You think about the words that you want to use. You think about the way that you want the other person to feel. You think about the way that you want to feel as your explaining the thing that you want to share, right? And you expect them to be wow, I think that's the best idea I will probably ever hear in my entire life and they don't act like that. They're like, okay. Great. I have to go to lunch now. And so you're confused as to why this person isn't as excited as you are about this thing that you think is so, you know, great. Well, the problem is, is that you don't care about them. You don't want to have like a two-way conversation you want them to love your idea, the way that Kanye loves can yeah.



[Laughter]



And this self-focused approach to communication is a breeding ground for lack luster conversations and it can even cause problems on teams. So what do you need to do and how do you fix the problem? You need to think about the other person. You had to be empathetic much the reason why is because, you know, is because empathy fuels connection if this is true, empathetic communication is going to drive collaboration and when it comes to building teams, to building products, one of the most important things that has to be positive is the way that you guys collaborate, as a collective. This presents us with a problem. In 2016, the way that we collaborate is almost exclusively Vee A you know, flowing screens, software and text. Which is fine, because there are benefits to communicating in this way. Teams have said because being able to talk to each other. Via twitter, you know, it helps sharing. It helps people feel connected and it also helps to build a common ground.



When you are communicating exclusive via text, you know, being the empathy that you have to have in in order to connect is oftentimes, lost. So technology is extremely helpful. But it can't replace the social aspect of face-to-face communication. Failure of communication can't just be automated away. You have to confront things face-to-face. If you take away the technology, take away your cellphones, take away computers, take away software, then what do you have left? You have people. So we are presented with a second problem. And it's that people hate talking to each other because talking is hard, and conversations are difficult and collaboration is extremely hard. And that's why collaboration, it does fail because it's so hard to talk to people. Sometimes. So let's figure out a couple of reasons why collaboration does fail. And the biggest reasons are, because people are afraid of being wrong, and people are concern they aren't going to be able to communicate their thoughts and their opinions in a clear way.



The fear of being wrong is the fear of being judged, right? I can't tell you the time when is I have had an idea, and I wanted to share it, but I was so consumed with the thought of of being judged, but I just remained silent. And being misunderstood, you know, this happens pretty much every day. You know, you guys are all highly technical people, and you work with people who are probably, you know, nontechnical people. And so having to explain things can often end up in just, you know, frustration and irritation and so, it's just a lot easier to, you know, just not collaborate. So how do we fix this? The first thing is, that you have to speak up and encourage people around you to do the same. Because silence kills collaboration. You know, hearing what another person has to say, it didn't make your thoughts and your opinions any less valid. All it does is enhance conversations.

Next thing you have to do is think about the person that you were talking to all of us are on didn't plains, and intellectually, emotionally, and that's okay. Speaking to people on their level, doesn't do anything to compromise your level. Next thing you have to do is think about the speaker. Now, you know, when you do come to a place of having a conversation, where the speaker is beginning to struggle in explaining something, just kind of think back to hearing me speak now, right? I know that it can be incredibly difficult to completely understand the things that I'm trying to communicate and you have to, you know, be patient. You have to, you know, really pay attention. So when you discuss your ideas from a place of great empathy, and you pay attention to, others' ideas from that same place, you are going to create something that is bigger and better than the things you could have created, you you know, by yourself. That takes vulnerability. It's the it is the vulnerability to embrace silence or to discuss the things that going to be, you know, an uncomfortable conversation. And that also takes courage. It takes the courage to listen to people when they are struggling to communicate. The things that they're trying to say. And the courage to, you know, kind of embrace them being vulnerable to you. So to be empathetic communicator, you need to be courage, you need to be courageous. You need to be vulnerable and you need to be patient. And that's going to be the foundation of a positive and effective team collaboration. Thank you.



[Applause].



RYAN: Thank you for sharing your story with us. We do have time for questions as well.

So if anybody have any questions they would like to pose.



>> AUDIENCE MEMBER: So I was really struck early on, you made the point about how people are often afraid to speak up because of either a fear of being wrong or they fear being misunderstood. I wondered, which one of those two things Do I fear most. I'm still wondering about that. But when I was reflecting on that further, I realized, some of the biggest jerks that I've known, we're talking about geniuses, but quite often, jerks, who do feel of being wrong, but they don't care at all. They deliberately choose their words to ensure they can't be wrong they have representations and they don't care about being misunderstood, they're leaving it up to the audience to misunderstand them. Maybe they have legitimate reasons for behaving that way, but I'm source of curious. I don't know what you think about this in terms of the kind of personalities that stops caring about whether their audience misunderstands them or not.



>> SHARON STEED: I'm pretty sure we call those people sociopaths. Like, they don't feel. They just don't care so they can live their lives in a way that doesn't like, yeah, like it doesn't matter if I hurt your feelings because I don't have feelings any way. So, I mean, in terms of the personalities for, you know, people who do have feelings, I think those people are a lot more thoughtful, like, they think about the things that they are going to say. And then they make sure the way they communicate them is going to both be positive, effective and it's probably not going to harm, you know, the other person. Because it's that's also really important, too. The way that we talk about things, and the way that we say things, has, you know, has a very large impact on the way that things are perceived. And so yeah, I think those people that care, talk to people in the way that the person has to be spoken to. Everybody else who's on the ends, you know, you probably don't really want to be talking to them any way, because they just don't care about your feelings. Unless you have to go to work with them. And then, you know, yeah. I don't know.



>> RYANN.  Anyone have anymore questions? Thank you very much.



>> SHARON STEED: Thank you.



[Applause].



>> RYAN: So our next speaker was telling me last night, about his experience working on chip design. But he's not giving a talk related to that at all. It's going to be about wood frameworks which is also really cool. So I'm excited about that.

But I think you should talk to him about the other stuff. That's really interesting, too and so, gettings things set up here. So we're anything to have Matthieu Wipliez talk talk. So round of applause, please.



[Applause].



>> MATTHEW WIPLIEZ: So the remember title of the talk was supposed to be, Techniques for Writing concurrent applications with A synchronous. I had all the contents of the talk, for reasons, that hopefully, will be apparent later. So first, I'd like ton about you. Who has already used A synchronous I/0 in Rust. And who has used it in something other than Rust, maybe not JS. Okay. Cool. And so this talk is about I/Oin the context of networking. So I want to talk about file operations. If we do have time for questions maybe we can talk about it. I'm the author of the web framework. Called edge, and that's how I came to learn about a sequence. I help because I use the framework called hyper. Which you might be familiar W. and it actually switch Friday synchronous I/Oto Asynchronous I/O. So before we start talking about Asynchronous I/or, I think it's important to start talking about synchronous I/O. That's what you do, that's what do you in Rust, you know, out of the box. You have to trace when to read, when to write, and the typical use is you are going to revise from a stream, create response and Sundays these responses back to a writing industry. So by default, all of these are blocking. So when you want to handle multiple connections, obviously, you cannot use just one. You have to create like one connection. So the architecture of Asynchronous I/O application, one or more processes and each process will have like 1/3 the connection, right? So if you have end connections, then you're going to have end threats. So how does that look in Rust?

Plaintiff.

It looks like pretty much the way that the architecture was presented. So you have a listener, and then for each incoming connection, on the current thread, you're going to spawn a new thread and handle the connection there. What's the difference between Asynchronous I/O. You have a fix it thread and its thread, actually hands out a set of connections. So you have like, instead of sockets in the context of networking, and it is going to pull to see each socket, whether it needs to be and then tell execute these operations, using non-blocking calls. Okay. So what are the advantages of the Asynchronous I/O? So there are three main advantages in terps of reboot, the number of request for significant executes, in terps of agency, so you can respond faster and in terms of memory consumption. And it turns out, that's especially the case in web servers so some folks at dream post, actually made these bench marks to see what the difference would be and apache is traditional synchronous architecture, and despite being a point slower not that other two. It consumes much more memory. So earlier, William selects and tile, it's interesting to look a bit about the history of the synchronous. So it didn't start with JS and it's actually much, much more than I originally thought. This is one of the good things of doing the talk. So you can actually, dive deep in history. And actually, I'm not sure I was born when select, when it was implemented and later on, the system came to Linux in 1987, and something interesting that happens in 2002 for Linux, we started to get it's implementation. So for Linux, the main difference is scalability. So this is a figure so the difference is the performance of Epole will remain constant, using Asynchronous style, because we know it sounds like magic, and there's always something behind magic.



Since you're using one thread to manage many connections, and you have to enter the connection in a timely manner. So from the left you have the Asynchronous approach. You receive connections and the time it takes you to handle those connections, for instance, your handler is going to from the other side, it's going to take one second, 200 connection. But then, it's okay. Have you multiple threads,.



In Asynchronous mode, caps is that instead, the first connection is handled, the thread will like, do its thing and then only when it is processing this request, will process the second one and so on with that being said, let's see how you do Asynchronous I/O. So the good news S there's blocking with libraries. Rust is 1.9. So the deference is instead of having a block, instead, the call would return an error saying, you know, I cannot perform this operation and you told me not to plug. And the problem is that there's no pulling API. So but luckily, we saw that earlier. This is MIO, that stands for metal I/O. The way it supports is by using the underlying libraries so Epoll in Linux and windows, I/O. And it's 0 allocation and it is scrolled back.



Now when, you use it directly, this is actually, from the examples when they get the repository and that's just for an equal server and that's just handling the connection for an echo server. You get that data back. And this is only the part of care and the structure and to write data so maybe there are some spectacular cases where it's interesting to use my directly, but in practice, what I would recommend is that you use another crate on top of it that would actually take some of the pain away. Or even most of the pain away. I mentioned a few here. These two are using a cogene approach to do their arcsynchronous I/Oand last crate quite recently, this is the library I will talk about.



So why tokio? You don't need to say, hey, look, I'm interested in read events or write events or any of those. Tokio will just infer this for you. It will know you want to read later on and you want to write later O. also, it's a futures' based, Asynchronous IO Oli /O library.

The idea is it's a different computation. Means it's a piece of code that will get executed at some point, later in time. This is, I'm not sure it's in the latest branch so this one is the hyper solution, maybe, how you should define a hand ler so you would need to implement the straight and get called back when there was a request coming in and you say, okay. Now, based on, you know, if this request is a pose, I want to read from the France port. And then it will go on request. So to say, maybe I want to write a response, and it kind of, you know, gets not very natural or it's a bit clumsy. So the author didn't really have a choice because at the time, he was just wrotor and is now in with Tokiyo. So moving back to futures, like I said, this helps you go back from serving, instead of having nested coals, you have this nice, beautiful, flat structure and it kind of, it maps quite L I think to the way Rust already does, you know the [indiscernible] and stuff like that.



So the wave of the future is defined -- okay. So this method returns a result so either is an error and okay . if it's fine, you have two choices. If dataa is not ready yet. Maybe it depends on another call. Waiting from some data to arrive. Waiting from another computation to complete. Then you say, okay. I'm note ready yet. Or you can actually return results and then you return Asynch ready with a value. So there's also the [indiscernible] set for stream. A non-blocking, and the idea is that so you return either some value when you're ready to do so or known and known means it's the end of it.



So what's the relation between futures just a quick note about futures and not blocking. So futures should not block when facing I/O in general. There's a wait future, you should not call when you're inside ray future, otherwise, it will just wait and not advance in the current thread. So actually, I made that mistake once. If your program needs to do computer intensive work. Things like, maybe resulting -- then you should use a thread pool. Every time you do a blocking function, which can be a bit heavy-handed, you just submit a job as a closure, and this job will get picked up and executed by one of the threads that's available. So the notion of thread pool is outside of futures. It just turns out there's an implementtation of road pools for futures which is called future [indiscernible] poll.



The way that Tokia I want greats, you get all this low-level stuff. All the call-backs am then Tokio core takes care of registering the interest and exposing the future base. On top of that, you also have a higher level of services. Tokio proto.

It actually started in August 2014 that's a bit over two years ago. And the author MIOis also the author of tokio.

And we see in March this year, the futures are straight and then N August of this year, a number of interesting things happened. August 3, Tokio is announced. And about a week later, there's this crate called future officially is announced and yes, non-blocking calls and for computation and it actually turns out there's a crate called futures MIO talooks good for Asynchronous I/Oalso. So you know, I was in holidays at this time, and I was thinking what I'm going to say during this talk, and I was thinking about talking about all the stuff, as I had to do in my framework. And I say taactually, you know, it's changing things. It starts to look, you know, very interesting to do Asynchronous I/O.



Luckily, two weeks after future is announced, then the three authors announced together, the emerging parts of the project. So that's futures might actually become tokio core.

All right. So we go to what's called the core of the react O. I don't know if that is intended. Probably yes. To the core of the reactor is really like the heart of this.

So it creates the loop. You start listening on the IP address and port, so what's next, the incoming returns the treatment of connection. That's ray none blocking stream. For each stream, you run and the first return ace future and that future is execute on the loop. So to do actual handling of the connection, you need to put that in the call for each method and that looks like this so you get a stream. That's inIng connection. And what you're going to do, you're going to spawn the future on the loop. The loop will actually run, the future that's running a code. One of the incoming connection rides and it will also run every closure, every future that you create to handle the connection. And so, let's see, maybe let's take some action. So I've chosen in this case, just for this. The identification protocol. Which I think is I don't know if it's still used outside of IRC. So the idea is that it was originally, I think in the context of FTP or something like this. And the idea is that the clients that you connected to, want to know who you are. So they will send you a request and you will reply, the operating system and user. It's a line-base protocol, which is nice enough to, you know, maybe make some experimentation. So I think at this point, I have you can see this. So so zero. If you say okay. 1, 1, then there's no user because there's no connection from port 1 to port 1 and if you point to a connection, like this one then it returns the user IT and the breaking system. Yeah.



So how do we do this with tokio? So first, solution I'm using only tokio core. It was like higher level layers. What I want to do is just realign, you know, try. So I realign and I would process that request and get reply, and then write all the replay to the stream. And I'm not ready yet to finish because there might till be some bites available. This function returns, and tokio will see, depending F it D we'll come here again and it just looks like this, until there are no more [indiscernible] read. Asink, I'm ready with unit results. So there are just a few problems with this implementation. So the first one is that I use the perfect reader because it was the easiest solution. But it actually turns out that the reader will try to will try to fill a buffer in the fist eight kilo bites. It is not enough to fill the buffer. So Republican error, saying it will block. Also, that's probably less of an issue here, biin theory, it could also block. So right would not block. Once you use that, if you want all the response to get sent back. There are possible solutions to improve the implementation such as using buffers, so you feel the buffer. Whenever there's a line separator then you will process the request and using the same thing for the right side and you can do that perfectly. Or you can use streams so you transform the incoming bites into a stream of strings and handle this with the future.



There's another solution that uses tokio service, which is kind of higher level than this and actually, it looks like what you might want to do so the idea of the tokio service architecture Uyou no longer have data bites comeIng in. Bites coming out. You will actually parse those bites into whatever you want to do like a request, and this is transport layer and then request gets given to the service layer while you do the actual handling of data.



And the handle, turns into a response, and thence response gets sent down to the trance port layer and timely, it gets sterilized. And sent on the stream. So it's just a matter of implementing two traits. One is called parse. The other is called sterilized. You can return or not or not that structure and it is the inverse separation where it gets, where you get the structure and you get to describe how you're going to send it all right. So now, all that's left to do is do the actual service implementation. So far that, I'm using a little help or function for tokio called simple service. So the service traits I don't know if some of you use the service trait directly. And the service trait has, I think four types. Input, output, the future type, the arrow type and it's just a lot to implement like, four lines of code. So simple service what it does, it will create an instance of simple service from a closure that returns a future. It's slightly simplified, otherwise it would not fit on the screen. Implementation, the idea is like this.

To define a service as a simple service from a closure, you associate the strands port and finally, you create the service, the server, using the service and transport. Every time you get a connection, you will create a transport for that connection, create a service for that and pass it to this server, which is done by tokio itself. To conclude this talk, as we have seen at the beginning, it leads to high performance. At least it does for web servers, probably like, with low-level, time constraints, A parentally, it's a bit different using higho or high-level stuff. That is for networking. It's very interesting. And there's a rapidly evolving ecosystem, especially as I said, what happens in just in August, and so things are moving quickly. But I think that this morning, Rust is at a turning point, in the sense that look great to you and tokio. Try to play with it. You know, use a simple example, maybe use futures blocking implementations and crates. And yeah, that's T. thank you for listening and if we have time for questions yeah, feel free. Thank you.



[Applause].



>> RYAN: It is my great pleasure to announce that we have time for one question.

[speaking away from microphone]

I'm wondering can you use the same event for different acts of [indiscernible] safely. For example, can I have the same event with a couple connections and [indiscernible] connection?



>> MATTHEW WIPLIEZ: I'm not sure I understand the question.



>> AUDIENCE MEMBER: So the event,.

[speaking away from microphone]

The connection. In the same event, kind of like a different side, not just a metal connection but [indiscernible]



>> MATTHEW WIPLIEZ: I don't know, actually, you mean different protocols if the same loop?



>> AUDIENCE MEMBER: There's different type.



>> MATTHEW WIPLIEZ: So I think in theory, it's entirely possible because you know, I know that's the crate n allows you to maybe have http and htps in the same thread. I'm not sure how to do that in tokio, actually. So maybe it's possible. I really have no idea. Thank you.



[Applause].

Push.

>> RYAN:  We're going to take a 15 minute break and our final keynote and the wrap up for the day. So we'll be back in 15 minutes.



[Break Taken]





>> RYAN:  Can we get seated again.

So I'm going to introduce the last two sponsor Zucks. So I'll make it quick. I already gave my talk this morning.

>> Thank you to all the sponsors, Microsoft, as the menu pops or here, I think they made a really great day and made a really nice conference out of this venue. Our corporated partners. You might have seen Ben runs around. As tomorrow, we will have the venue and I'm leadership looking forward to that.

That makes me introduce our first even sponsor introduction, Microsoft employee, Ryan Levic.

[Applause].



>> RYAN: Hello. I'm a Microsoft employee. Crazy. Wasn't that guy the M.C.? Yeah, I wanted to talk about Microsoft in general, a little bit about Microsoft here in Berlin, for the people that are in the German area and throughout Europe that maybe would want to come work here and talk about open source at Microsoft, which is still something that a lot people, including myself are getting used to and touch on those topics, and if you want to talk to me later about any specifics about Microsoft, then feel free T. I would be happy to talk to you about it. My personal story is that I work for a small Berlin company and made an app called wonders and it was purchased by Microsoft so I'm new as well.

It's been about a year now. I'm starting to learn my ropes but I definitely have seen many sides of Microsoft. One thing I wanted to show, I don't know if everybody saw this. This is from GitHub Universe and Microsoft organization is the number 1:00 over open source on GitHub, which is just fascinating. If you would have told anybody in this room 10 years ago, they would of course very, very surprised. But the cool thing, it's becoming less and Les surprising every time, I see something like that. Microsoft and open source are hand in hand together and there are many times I've gone to the Seattle team and they were full time on open source. Everything they do is out in the open and interesting as well, they don't work on windows. So there's a lot Linux hackers and things like that will so it's sort of, I don't know, not what you would have thought of 10 years ago for Microsoft.



Here in Berlin, we have a couple of teams that are working on various products. One of them wonders and we have a couple of people from the wonders teams here. Yeah. Cool. We have got a couple people here. And I'm working on another project as well. I should just mention briefly, we are hiring for both teams and we're looking to expand the office here in beer lip as well to be much larger than it is now. So if you're ever interested if opportunities there. I'd also be happy to talk about those. I also want to talk about the ability of Rust at Microsoft as well. It's something I'm very passionate B and it's a really cool thing to work for a big company that has a lot of sway in the 43. I have this fantasy of one day writing that block post like we just employed this massive product out. And it's written entirely in Rust and that would be awesome. One problems I'm working on right now is sharing code with Rust. We have a lot of shared sequence C++ code, for instance, and it would be really cool if we could move some of that to Rust instead. I believe, Excel finally got rid of all of its if-line assembly, and is now using C++ spiral, which is good. If you're interested in talking about that, how someone can share code, between different platforms, IOS, android, Mac and windows as well. To share a logic between apps, I would definitely be interested in talk to you about that tomorrow in a workshop. We can sit down and hack some stuff together. So that's all have I to say. If you have any questions, and are interested in learning anything about sort of the way that open source works at Microsoft now days, come catch me sometime. So thank you.

[Applause].

>> Hi,en, I'm Steve, I'm here to represent Mozilla. You know us as the fine finest purhave aers of -- ervayors of human interface us. It's someone who has been in technology. Using fire fox. I remember fire fox. And if you would told me then, you'd work for the same organize. I'm really happy to work on Mozilla. I'm going to use this next five minutes to talk about other stuff. As a member of the Rust community team, there's been a lot of really interesting new projects that of course happening. I originally started the community team, but Steve doesn't scale. So I've been focusing on docs and Eric has picked up the slack there and has been doing wonderful things. Tomorrow we're going to have the first ever Rust ridge workshop. I come from Ruby rails and railsridge, moving intoxicator languages so we're hoping to run workshops all over the world and teach people how to program and teach them Rust. And collecting community resources, helping others run great community-run conferences like this one and put on, things so I think one of Rust's strongest selling points is a community. They're all wonderful people. And thank you much for coming if you see me, feel free to come ask me.

[Applause].

We have our last speaker, do you want to come up? Our last keynote for the day. Is a speaker that comes all the way from Brazil. She runs the SAO Paulo Rust meetup and she's going to be talking about science and Rust. Which is very exciting. So breeze, a warm applause for Hanneli Tavante.



[Applause].





>> HANNELI TAVANTE: Fun time. Is the connector safe? Should we borrow another one? Don't panic. (Pause).

Okay .

Hi, I'm Hanneli. I'm from Brazil, I'm a software developer and as our friend told us, I started the Rust in Sao Paulo care. Today, we have about 300 members, which is something. We have been running the meetups for around a career and we can proud a meetup almost every month, and some are happy to see we are growing and usually, we have some volunteers front some interesting topics, such as implementing genetic alrhythms with Rust, implementing the basic concept of the language with pokeman. We had this talk. So I'm happy to see this community growing. During my free time, I like to do these things here. I like pokeman. So if you're playing pokeman go, we can walk around the city to catch some pokeman.



So this presentation is about rewriting code in a talk called octave F. you're not familiar with octave, I'm going to talk about this in the further slides. But as a bonus, even if you are not working directly with Rust, I expect that by the end of the talk, you have an idea of transforming some math concepts into your code. In ray very expressive way I'm going on show you step by step, how we started building some codes in Rust for active. So this is going to be, kind of, you know, addressed so there is some code that actually doesn't run. In the last slide I'll leave you with reference so can you get the code from GitHub and run it. I think nobody is requesting to be scared about the math that there is this presentation and to help us to keep firm until the dinner time. Let's start taking about some training tools and science. Training tool in science are becoming very popular probably has consequence, some of these tools, based on Corcera. Everybody here didn't know what scorecera? Doesn't. It's very popular. EDX is another popular, too. people who are develop developers, people who do not have a background, it's pretty exciting. This is like bringing topics like data analysis, big data, to people who are not connected with research. Which is pretty interesting. I was talking to some students, that graduated maybe last year. And they were telling me, they use some of the tools to help them with mathematics. So one is octane and it can help you, if you are for example, electrical engineer trying to solve some crazy and differential equations for very difficult and you need hands on software to provide support. I pretty much like Coctave. But I had difficult times, during my under grad year when is I was doing research. I usually had a problem to resolve, low frequency inverseer, trying to figure out how to implement that I would spend a lot time on things that have nothing to do with the Ochave. For example, I was getting a tangle or I forget to reallocate memory and everything blowup want that was kind of frustrating to me. I'm not saying like, this happens to everybody. But you know, very hard and difficult time. And pretty much, all the other tools were open source would provide meet same problem. I had trouble to extend the functionalities of the tool. And I was surprised because when I ask the students if they like it, they say yes. But we have trouble to express mathematics, with C and C++. That's the case you end upping a lot of time or something else, rather than spending time with your problem. Then I started to think about the possibilities that we could adapt to resolve it. I was studying Rust at that time. Version 1.0 was just released. I spoke about Rust and they accepted to try the language and see if it could help them with the problems that they were facing. So Octave if you're not familiar with the two is pretty much useful for machine learning for data analysis. For maybe, something, some calculations that it needs to do with computer vision and things like this. It's useful for example, operations with matrices, body charts, statistics, and several other areas that have some heavy population sets, you know, you don't want to resolve everything by hand. A good point about Ochave is it is open source. And open source is pretty good. It usually extends the existing libraries and things like this.



This is what usually happens when you're doing research. There's a point when you need to add your code to an existing, too. For example, there are lots of external publics that people bell for Octave and they are available on GitHub or any other source repo. Then can you easily, you know, add your contribution to the tool. Which is amazing. But sometimes it's not easy to handle. A very famous data structure is this one. It's very likely that's one date. At any point of your life, you receive this spreadsheet. And a spreadsheet is a table. So we have to handle tables or better, matrices, in several scenarios, several distinct scenarios, right? Why matrices are so important. Everybody Sundays me spreadsheets. No. Not only because of that. Matrices, they can represent us in several different areas, and sometimes you're not aware that you can represent something with a matrice. But you actually can. So, I guess one of the first context taw had with matrices, was in high school. But not sometimes, not even in mathematics, math classes, was something else. To remember this law here? Ohm's law. You have this, you have the voltage and then have you this relation, other resistance in the voltage. And then, you can make this even more sophisticated. I'm happy because it talks about [indiscernible] today. So, I guess it's scared of this. Even if you failed in physics class, you might remember something like a circuit with voltages for the resistance. By the way, those are the [indiscernible] flaws. You have a bunch of equations and find a value for every variable that you V and involve it in the system. So there's some work and figure out what the value is for, the resistance 1, 2 and so on. But for linear systems, there is an alternative representation, rather than this one with the curly brackets. You can represent with matrix. And there are advantages of representing linear systems as matrices. We can apply several different rules. For example, there is what you call the turn -- several different reduce of finding properties of a linear system. So understanding a little bit about matrices helps us a lot to resolve linear systems. And linear systems, they are a structure which is, which you can find in several different areas. For example, electrical engineering. Environmental initialing, healthy environments, behaves in things like this this is part of the code you have to represent an array or a matrix in compiler. This is the code base for array and a class called matrix. This is a very expensive code. It has around 500 lines, something like that. And it's pretty much plate coderation.



So those students that were talking last year, I asked them what, is the most frequent structure that you use in octave.

How would you build a matrix in Rust? Vector. But a vector, how would you build your own? Come on. You know that truck. Let's build this truck called matrix. Makes sense. Makes a lot of sense. So tell me, what's going to be. Think about a matrix. Think about this matrix here that you were on the right side of the screen. You have rules. You have goals. And there is something inside the matrix, which are the matrix elements. That makes sense. And this is simple. This is the very first step that you have, in trying to build a representation a matrix. Makes a lot of sense.



We started discussing something else. So for example, you can remember your math classes, when you multiply matrixes, can you multiply any matrix with any other matrix if no, there's a rule. So on the right side, you have a matrix with two rows and on the left side, a matrix, with three rows and 4 columns. Can we multiply this matrix tricks? Yes. The number of column equals the number of row in the second matrix. So yes, we can multiply this. What's going to be the dimension of the output matrix we have some rules, based on the matrix. Interesting. We have to keep checking. Did I mention, every time but this is what you do in C++ because of the template. You have to keep checking all the time. This is not very convenient. How can we prove this code? We want to add some behavior. Structure. So this is a bad representation. Don't do that.



Instead, create a trade. Call dimension. That makes sense. You can ask all the behavior, based on the dimension of a matrix inside this code and this is going to be much more explicit when you give Rust to matrix you don't have chief Pence trying to, you know, perform an operation with matrix, with dimensions that did not match. This is pretty interesting. I was reading something on the Internet. So there is a link, at the bottom of the page. And he suggested that we should use phantom data, when we were presenting a matrix and that makes sense. Can you picture in your head, a matrix without any element? Doesn't make much sense. Is this kind of thing doesn't exist. And this author was saying something like, you should have elements representation. Which you can do by using phantom data or you can create your own type of matrix elements. Kind of doesn't matter. But this presentation of a matrix is kind of much better. And much more well structured than our nation presentation where we had rows, columns and something pretty vague for data this is how the end yearis I. implemented. Any kind of array has been mentioned, as elements.



Next challenge. Can you think of codes to represent clear matrices? Does it make sense to have a code for matrices, in terps of the common and most used mathematical properties that have for matrices in yes, makes sense to utilize squared matrix. Base on the matrix itself. You can fix the dimensions. So the dimensions are always equal want and then you can derive a bunch of code from this initial code. So its pretty convenient for us. And with that. I hope you had a very quick overview of why linear is important and why matrix are important. And I really hope you can follow the main idea of how we get a mathematical concept and we apply this to Rust. That was our very first attempt in the final codes, that we're using, was pretty much like this one. And everybody's kind of happy with that. Another important structure that students research this a lot. Complex numbers. If you come from an initialing backgrounds, you're very likely to have seen a lot complex numbers. Do you know why there is a reason for people to keep using complex numbers. Do you know why? I mean, a good explanation, because they like T. there's there's an imaginary part that's a school. This is not a good good, you know, this is not a good point. For example, computer, which is a very nice subject. Everything is based on complex numbers. It's easier to differentiate. That is one point. But you can differentiate different numbers as well. Of minus 1. So there is a more generic reason to use that. Let's talk about this. This is kind of the off-topic moment of this lecture. But I hope that after it session, you share with everybody why you use those numbers. There's a single mathematical reason for this eqivalence. Why doesn't it exist? This is true. This is true that makes everything much more simple. Let's talk about this.



Let's start from the beginning. Integers. I'm happy because of the very fist keynote of this morning, we were talking about integers, and real numbers. But we didn't reach the complex numbers, which are so important. So when you add an integer to another, what is the output? Anent jer. Glad glad it's an integer. So when you're talking about the operation, the output equals input. To the type. But that's not true. When you're talking about division. If you divide an integer by an integer, what happens? You may not have an integer as a result. May not. There is a chance it is, but there's a chance it's not. I added the letters that correspond to each set by hand. It's pretty August ugly. I'm sorry about that there is a set. Which if you're not familiar of the other sets. You can easily copy this concept from the keynote headed this morning. What is the most inclusive set that can be using. They're real numbers want okay. Cool the numbers. 0 is annex collusion. Don't consider that.

There is something even more generic than divided by 0. Is there any other operation you can think of, somebody already told the answer. Yes. There is an operation you provide input and you might not end up with this one as the output when you're looking for a square root of a number. If you're look for example a square root of -4. The result is not going to be a minor number. So this is sad. So the thing here is like, complex numbers we say they are closed for the most common operations. So if somebody says that this operation is closed, you can be sure that staying put is going to be as the same type of the output. And this is convenient for functional programming if you're talking about types you weren't sure of the output, the type of the output, and you can, you know, dereef lots of things about that. Can we express this property with code? Yes. It's not difficult. For example, you can have this structure here, called complex number, that has the real and imaginary parts and all the mathematical operations are going to result in a complex. Something like this. This is pretty much straightforward and convenience. Maybe sure the existing types are closed operations in a certain scope. Which is very convenient for several operations and initialing. Sometimes engineering, want to be sure that the output is going to be equal to input. This is much true. Think about T. Rust is very powerful. You cannot have the behavior. Even for existing types. There's probably somebody doing that. Because the biggest tools you have for initialing, they still using using imperative programming or if some language, that sometimes you cannot have this level. It just create ace trait, and that's to an existing type.



The complex numbers are already part. So you do not have excuses to keep usings open stats for your most common operations. I think I still have time. I don't know who's counting the time. But some lessons learned. There are really great skills to help mathematics, in terms of engineering and general science. But I don't know about you, but I've been struggling with the tools for a long time. Besides math lab and compiler, for example, we have VHDL. It's the language that describes harbor. If you think about VH -- couldn't we be using Rust to strike hardware. Based on the sessions to date, yes. But could Rust become a substitute for VHDL? Maybe, yes. I had a very hard time with trouble that I couldn't, I simply could not represent that and maybe with Rust, we could improve over the system in general. For me, it was pretty sad to change my focus. I was trying to solve a problem. How can I optimize the trails of the circuits and I should resolve this and this and this. Trying to solve dangly pointers or something I did in the middle of the code. Then it was not very productive to me. It was kind of time consuming from my research is something that should be training my time of that research. I had a very difficult time and sometimes I wanted to add behavior, an existing type, so I had to create another class with another set of descriptions, and things like this and with Rust, I don't have this problem anymore. When I learned highway to program, the examples were like with animal. Class animal. And nobody taught me how -- nobody tells me, hey, here's, I don't know a differential equation. Now you get this equation, and transform this. People voter to say, now you use numerical methods. Of course they can represent that. I was just using the wrong language, but there is a way to represent the mathematical structures in a more natural and straightforward way. One last, but not least point I was so happy, the compiler was telling me something, that something was wrong before I'd run T. something very frustrating to me is like, compiler can be slow for some operations and I was writing an operation in compiler and boom. . I wanted to cry. I lost 10 minutes to get a runtime error. I was really sad with that and some of the problems can be avoid for us. With the certain types, the Rust compiler can tell you, hey, don't do that because it's wrong. I don't have the responsibility anymore. I just 38 throw the responsibility to the compilers in certain cases. Connecticut collusion I took from there talk to the students is like, why don't you have many people join that. So we have concepts and mind sets, based on the thought that can be applyd to other areas. For example, a mathematical concept, but we can apply that to, I don't know, maybe payment. Think about it. So maybe you can maybe if you can describe mathematical property, more easily and more trait forward in a programming language, maybe we can start using laws of mathematical concepts, on a daily base. Sometimes I see lots of young people asking, why do you have to study Calculus. Sometimes it's not obvious. How can you be applying these concepts in real-life problems and maybe problems of what developments or I don't know, payments or products and things like this. But if we had a more convenient way to describe mathematics, into programming, maybe we can spread this knowledge across, you know, other areas of the industry. And maybe you can make them more popular. Well, that happens. So I share the good parts and I'm going to share the things that went wrong or almost wrong. So request I started learning about Rust I said oh. there's this thing called unsafe and I'll probably never use that. If you need to integrate Rust with another language. Sometimes you need to use unsafe and I found myself, like every time I had a problem, I'd type this mag call word at the beginning. Sometimes yes F you're doing a full baggage of language, C or python, there is, you can have your unsafe methods or your unsafe function but you should not expose that so you have something else safe. Let the method handle the possible problems that it might end up W. I'm telling this, because I was aware of this but you know, my body refused to do it. It was much more convenient to type them safe, until somebody uses the library and says, Oh, everything is broken. Why. It works on my machine. So make things safer, it's good advice.



There was another example. Safe and unmute F. it's not working, just add mute and everything will be fine. You have fun time, which gates signal, which represents on time, and you opt with that as a signal of frequency. And the same for the case, you have a signal frequency, and back to signal time. So I was use something libraries, because mine was not working so I decided to [indiscernible] mutable aces. I was happy with that. In terp in terms of concept, you're settling something mutable. Once you have the sampling of a signal, it's never going to change. So it doesn't make sense in terms of code. So I was writing a convenient code in terms of programming but it's a code that doesn't make sense at all. In terps of presentation. So when you're going to write. When you're going to write, think about this.A oh. wait. Does it make sense. It doesn't make sense to represent a mutable signal with mute, for obvious reasons. Actually handle your construct into the perfect way. So I'd like to use some references here. The tool for linear algebra, and I was reading the source code. You can actually find some structures that are pretty much the same as the once we saw at the beginning of this presentation. You're going to see that inside of phantom data, they have, a bump of interesting approaches to handle any kind of array of end dimensions. There are also some papers about Rust types and how can like how these types can help you or science tools. It's the FTP link you see there. And of course, some well known references like the nome. Like the dots. And there is one very interesting and probably also well known one. I don't know if you edit here. No. Didn't. I can edit later. It's a tool about FFT in Rust. So some special thanks to Florian. I'd like to add, no, no more [indiscernible]. Bruno is also help being the Brazilian community, and thoughtworks has been hosting most of our meetups. For my mentor, Daniel. And for these people who provide me gifts and of course, for the Brazilian Rust community. Thank you and I don't know if I have time for questions. We don't have time for questions. Ty.



[Applause].

Is.

RYAN: We do have time to wrap up the day and that's what we'll be doing next. How's everybody feel something you know it's a good conference at the end of the day, you're just so incredibly tired because you've been spending the entire day thinking, but at the same time, incredibly inspired so do you want keep going. And your body's like, urgh. Doesn't know which way to go.



So good evening. We have an advertisement. Oh, yes.

>> I'm Andrew.  And I've been at a great advent our. I have to take a break because I'm going to Pittsburgh lastmonth for the last Rust conference of the career. So I invite you all to come, and can you bring your friends because you probably have American friends that are very dependable. It's going to be very great. Can you see our friend, an organizer of this conference, he's speaking there. Ashley and Steve will be there. You're more than welcome to Much we have a coupon go if you go to Rust build Rust.com. And code is RustFest. You'll get 20% off. Definitely share it on twitter and everything. And we really want you to come and have fun and learn more. It's going to be kind of like this conference. There's a day of workshops and a day of talks and it's community run and run by people like carol, on the community team. It'll be awesome. So please come.



[Applause].



>> RYANN:  Here's the information if you want to take that down. If you need T. RustFest day 1 is almost over want you have to listen to me one last time. Some news about tomorrow what's going to be happening the first thing to do is to look at activities,.eu. We have information about the workshops, information about Selfie stick fencing, and more. And feel free to add your activity ideas as well we have submit workshops happening here. The embedded one is happening here. Sorry. Embedded one is happening here. If you have any ideas that are not part of an official workshop, feel free to stay here and can you work together. Try and find people with similar interests. There's also places to just chat and hang out. And we have work shops, those are going to be low stack. Then we're going to have web and crypt Crypto. They're all going to happen at the same time. You can all bounce around. We have the Rustbridge work shop happening and that happens at 9:30. So there's information about where these places actually error. You will probably already be here, but as we have talked in the morning, and we can go over to these places together in big groups. Make sure you have a metro ticket with you. The important reason for that is we don't all want to go down to the subway station and try and buy ticks all at once and have 80 people buying ticket it's once. Buy yourself a day ticket or a multi day ticket if you're going to stay longer in Berlin. And come back in the even. We have a talk and a prize and I won't tell you what the surprise S. it's a surprise. So what's left over for today? What do we have to look forward to? Dinner. We have dinner here. It's going to work very similarly to lurch, so if you want to not stay in your seats, sorry about that earlier. But we will have people walking around serving dinner. One thing to mention about dinner that's different from return. If you get a meal, try and let the waiters pass by you a second time. So other people can get their food first. Once people have eaten, then go ahead and have seconds. There's plenty of food. We want to make sure people get food. We have parties that are happening and eatery party. One party is pretty easy to reach. If you don't already have a wrist band, and you want to go. Get those, I still believe those are available. Make sure you head on over there want it's just taking the subway down to the stations and I'm sure as there's going to be a group going that will be easy to find. You can always find more information, exactly about where it is. And more stuff about it on the on the activities RustFest.eu. Then we also have some a party happening here, at the Microsoft eatery, just in front of here. It's an open space with X-Boxes and surfaces, and you can hang out and stuff like that. They serve drinks, beer, coffee, things of that nature. We have food and drink that will be served here as well.

And that stuff is for free.

Push.

So you can do both. That's totally possible. The one aim party is probably going to last longer and will start later than the other party.





And is that it? I think that's it. So once again, thank you very much, everything, for the first day, it was a real success. Let's give a big round of applause to our speakers.

[Applause].

And a big rounds of applause to our organizers for putting on as well.

Thank you, organizers if you have any questions, feel free to ask the organizers. Anything you want. You can find information on the website as well.

Without further ado want let's commence the even activities.



[Applause].

[End of event











[Please Stand By].



hello, hello, good morning, we're going to get started soon so please head to your seats. Thank you.

>> So many people. Cool.

>> Good morning again. How is everybody feeling.

>> Good.

>> Yeah it's day two. You've made it through day one, now you're onto day two. That's great. So we have one talk in the morning and then we'll have, after that, information about afternoon sessions and such. But our first speaker today is world famous and renowned for inventing the great sport that you all know and love of sell fee stick fencing. So I know keep your photograph reto a minimum. But Sonja will be talking about hobby oriented programming which is great because today we're going to be participating in programming as a hobby I guess which is kind of cool so everybody give a warm welcome to Sonj

.

...(APPLAUSE)...

THE COURT: That's Ryan. Yeah, so my name is Sonja and I only have one shirt.

Laughter).

>> Furthermore I gave this talk before which you know makes this kind of similar from a key note from apple I think only that I'm presenting an improved version of my previous talk and it's an improved version because the wonderful people behind the conference where I gave this talk before is coding they sent me feedback after wards and generally I respond well to feedback.

So one could say it was mixed so there's a ten in there, there was a one in there, someone said it was a major surprise, I think that's a positive thing. Generic and then chaotic, that's fair, you know? Life itself is kind of chaotic. Right now I'm unemployed. Soon I won't have a place to stay, again. And over 95 percent matches on okay cupid I've been friends with before I even set up my profile. So no wonder my talks resemble chaos in a way but it will be fine, right? Because I'm still DOOG well in regards to MOSLOF hierarchy of needs it's a theory of human motivation and it describes the stages that we generally move through when we develop our personality and mind. So the requirements of every stage need to be met in order to move onto the next stage. And by default you know I don't have to worry about finding food, I have a safe place to sleep, love needs let's assume I figure that out too. So there's only one thing left to do that's the constantly recurring critical reflection of my own life and happiness. And on that note I would like to share a moment with you that's still quite vivid in my memory and I'll play some background music for this, hopefully.

And it was in November, 2014, Saturday evening, and 10:00 p.m. or something and I'm sitting on my couch, sipping some sort of liquor, and listening to a recording of the singing comet, I don't have sound, I think, but.

Music playing) while also doing some JavaScript exercising, and I consciously paused for a minute, because it's like this is rather strange, why is there sound in space? But also, this is the comet. So but also why am I at home on a Saturday night writing infinite loops crashing my browser, this is Berlin, shouldn't I be at the kit cat club throwing GLIT ter at people I just met on rinder? Possibly. But today's crisis is to understand the motivation and reason for late night hobby oriented program activities.

So when it comes to code I consider myself an amateur and I would like to know does anyone consider yourself an amateur? One? Two? Couple? Okay, that's cool.

And oh, yeah, my background is in GRAVENGS design so I had to put in (GRAFGS design. So it's considered a person who loves writing code, right? So that's the basic definition of it, and it's not attached to -- you know it's attached to particular pursuit study and science and in a non-professional and unpaid manner. So the definition shines acquired surprising -- surprisingly nice light on the term because amateur is usually con notated with negative associations it describes someone with low capabilities you know no particular depth of skill. So for that reason it makes sense to place the term expert on the opposite end of the universe and expert is a person with extensive knowledge or ability in a particular area of study.

They are commonly recognized as a reliable source of technique or skill, and their ability is based on a long-term intense experience through like research, practice, occupies. And both terms suggest particular assumptions about a person's level of skill, which only leaves the question if experts enjoy what they do, too. So with joy emotions are chaotic let's put them aside for the moment maybe in the quiet room and while we take a look at the general process of skill exposition.

And sucking at something is the first step of becoming good at somethingment and I run into things that I'm bad at, Felix key note for example, you know, I admit I didn't understand a thing but one day I will. And these talks are like poetry to me, they're beautiful. So recently I found odd and particularly bad at aqua PILUXING, it's a mix of Pilates and boxing and the story here is one winter I was just -- yeah, I didn't want to pay money to enter the gym so instead of searched for every training session I could find in the city. And I actually wish there was an app for that so if anyone wants to build that? It worked out quite well but in the end I didn't stick with any of these sports and I believe it's rather unlikely to pick up a hobby out of the blue.

So there needs to be a trigger something that switches on your curiosity your competitive spirit or maybe some good old peer pressure. And in my case there was my friend Daniel telling me to go to a rails core workshop and a galaxy of similar initiatives directed at various groups of humans all of them are fantastic and in fact this is today's the first rust PISH which I'm excited about usually a perfect environment becoming mature because you're joining a crowd of fellow learners and coaches pushes you through that frustration where you reach a point where further learning is possible as a solo activity. I'm feeling lucky because my friend Daniel not only recommended to go with the workshop but he told me how to curl and I'm forever grateful for this for his time and help I want to have that on record.

He was there when I typed my first, second command into the terminal he was there when he tricked me into renaming my local host, explained chrome to me and supervised my first attempts of writing JavaScript without pasting stuff.

I had to come up with a BROEKT for our sessions and what do you know we built my first online business it's a who are scope based on aircraft not star constellations disrupting the future of fortune telling



(Laughter).

>> You saw that coming right? It finds of closest airport to your location and that's all our team needs to generate a personal air sign. So right now it's free. So any I would right on I figured code it enables me to bring my ideas to life. When do I quit my job and pursue this new found parks at one point is parks am I good at it more importantly how do I know? The answer like all answers is in the book not that the book but the book which probably needs some explaining but I'll do that by looking at the game checkers. Checkers is a two player board game each player starts with 12 pieces on his or her side and pieces can only be moved diagonally forward. So a player tries to take the opponents pieces out of the game by jumping over them and first player to remove all the opponent's pieces wins. So I love this image by the way because did you see the floor has a checkers pattern, too? Any way, so in 1863 so one thing, so the game is an extreme example of a regular environment, but just basic condition for sustainable skill acquisition. So now professional checkers players they improve their game by studying the moves that other players have made in the past. They write them down and etch them into their memory. So in 1863 checkers reached its peak. It's the champion sheep between James wilily and Robert Martin's two notorious players facing off in a series of 40 games all 40 end in a draw. All 40 start with the same three to four moves, 21 of them are the exact duplicate of each other from start to finish.

So now the situation is only possible because BOETD players were experts with equal skills in the craft they knew the game inside out and probably each other, too. So both were playing by the book. So doing something by the book basically means not only STRIBTSly follow the rules but also apply perfect technique and that's pretty fine logical way to complete a task. So what if you know some of us writing code by the book. There must be a reliable indication of an advanced level of skill. Only that writing code is not like checkers, it's more like, you know, chess, maybe, because there's no finer boundary to the practice, you know? It's an ever expanding universe. Chess is also an example of a regular environment but the number of possible chess games is approximately 10 to the bottom of 120 and that's far more than the number of atoms in the universe. So now there is more modern chess players also have an extensive constantly growing library of recorded moves at their disposal which they use to study, as well. So even in chess there are whole sequences in a game that are played from memory and that not from thought but in every game of chess there's a moment that puts the book in its place. You have a constellation that has never occurred in the universe before. Both players are on their own it's a zero moment. The novelty, it's a situation that is out of book.

So when you get to that moment you feel you're life. And this might be the right moment to chat about emotions, no? Remember joy, happiness and fun, over there? So maybe that's start with an exercise, so one way how humans em paw CHIEZ with other humans is by copying their facial expressions so in theory when I smile I should see some of you smiling back at me, you know? Otherwise it would be frightening. Maybe it works better if you smile at each other? That made it awkward.

So now while smiling you can also trick yourself into feeling better because the muscles in your face basically tell your brain it's happy time. That's a crude version of the process but that's how it works. It doesn't solve any problems and it barely is the key to happiness, but what is that, any way?

And I'm glad to present to you today the ultimate definition of happiness. Which I found in a video by Alexander GA mm EY it's absolutely gorgeous I'll show you a minute of it, just to set the scene it's day 86 of Alexander's full return from saw Paula and he's about to pick up the last cash what he left behind him he has no clue what he left behind and doesn't expect very much.

(Video playing.) OF.

(Laughter).

>> It goes on for a little bit longer, so I find some other interesting THINGSZ. But I want to clarify that that's not the secret to happy life and all but maybe that needs some further investigation and speaking of investigations, you know sometimes maybe when I get board or I have a talk to prepare I go in and it's fascinating to see the hobbies that software developers get into when they're not working writing code at work. The craft of crochet, baking bred, Japanese archery, making soap, cats, of course. But the greatest hobby of all times the activity that most software developers get into when not writing code at work is writing code at home



(Laughter).

>> On the weekends.  Ryan, for example, from Ryan I learned that he wrote a chip 8 emulator in rust and from him I learned it was a machine and programming language which was using in the late 70 SZ on some computers as a basic gaming platform and now there's a chip 8 Rust emulator from the game pong which is awesome. Everybody says they take out extra work for themselves and I learned from Jane mostly from her work reality is BOEK broken that there's almost nothing that makes us happier than good hard work that we choose for ourselves. L that's a precise definition of how a game works. So when you look at any game it's usually a combination of four core ingredient, first there's the goal, it set the mission and purpose of the activity you're about to engage in, secondly there's rules, they tell you what's allowed and isn't. Some people see that as an opportunity to break them.

A feedback system is essential to tell players how close they are to achieving these goals and that they are within their capabilities and lastly it's voluntary participation. Which basically means making sure that everyone involved in the game agrees to the goal, the rules, and the feedback system. So Alexander he was playing the game return from the south pole, if you look at his exhibition in that way the goal was to come back alive and the rules were mostly set by the landscape and weather so every cash he picked up was a feedback system and I'm pretty sure he did it on his own device. Outburst of extreme happiness is a result of the game or in other words the unnecessary obstacle that he set for himself. So in a less thrilling STEN YAR Yo I'm sitting on my couch on a Saturday night and playing to code. And (scenario) and then everything changed, you know last November I start my first job as a front end developer from one moment to the other my previous hobby turned into a profession and writing code became a serious business that paid the bills and I had to stop playing and put my unverified knowledge to the test. As we all know that didn't last. What still last is the experience of programming in the professional environment and my learning curve went straight through the roof. There's no better set up for a junior than to pay a program with a seasoned colleague. So my programming partner said he has never talked that much in his life. I also had clearly defined learning goals and the proc speck spect to reach another level of skill and this gave me an essential feeling of mastery. Furthermore I COMBAM a part of something bigger, so accomplishing things together, sharing knowledge and making social connections it's satisfying, and it gives me an essential feeling of purpose, it's two very powerful concepts mastery and purpose.

They provide an understanding for kind of fascinating stories behind open source projects. From the perspective of conventional economics these undertakings are disastrous. How would one justify spending 20 to 30 hours a week producing sophisticated technological work without any form of reimbursement and after weeks and weeks of dedicated work the final product is released for free. It's kind of how the linking comma came to me through 12,000 programmers who volunteered their timeline NUKS was a chance to be part of something bigger than them SXEFS connect their individual contribution to collective outcome and being parts that unfold on such great skills you know it's an experience of curiosity, ahh and wonder.

Where does it leave us? Should we go to an aqua PILUXING, contribute to open source projects, get a cat, probably all of the above. But all I know is that whatever you get up to and there's one skill that I hope you try to practice vigorously and that's the skill of allowing yourself to play and potentially against yourself. And actually before I wrap up rather soon I would like to confess I haven't touched much code in the last two months which does not meet I didn't build anything but more related to rusty nails and wooden beverages in the forest. See my excitement on my face that's how I feel about today and the up comings are workshop so unless there's any questions I would say go place.

...(APPLAUSE)...

>> Thank you Sonia. Are there any questions? We do have time for questions. All right. If there are no questions we'll move onto information about the day.

So we have workshops today. That's awesomement it's going to be fun. When making your way to the workshops which are maybe not in this building, please follow the people in front. So all right. Let's give that another try. So make sure you're following the people with signs on your way there. We have some of the workshops at coop and those workshops are the low stack web and Crypto workshops. So to get there exit the venue to the left walk up the street, take the SBAHN, then go it's a short walk from there if you're not from Berlin and that sounds challenging don't worry there are guides to take you there and if you are from Berlin hopefully that's not too bad.

Here is a map and I think this information will be tweeted out and things like that so you can read it there. One thing to mention is to if you're from Berlin you may be thinking why don't I just take the U6, and go down turns out you can not switch to the U1 they're doing construction and it drives right on through so don't do that, that's the wrong way to go. Any other weekend it would be an awesome way to go but not this weekend.

So here's a link that you can find more information. I'll leave that up there for a second if anybody wants to take a picture. I see lots of phones. All right. Oh, you have to be quicker than that, no, that's okay, go ahead. Oh, yes, sorry, I already mentioned that. Yeah. Awesome.

So then we have the Rust bridge workshop. To get there you're going to go this way, here's the map. Everybody understands that, right? We're done. You're going to exit the venue to the right, walk to the U2 and then it's a short walk from there and again there are people with signs that will lead you.

Here is the URL for that if you want to take a picture.

The embedded workshop and others small groups if you want to meet you can meet in here so you don't have to go anywhere, that's great. Like I said, it's it's an open space if none of the topics interested you, but you do have a topic that you find very interesting and want to try to get people together then this is the place to do it. We're going to sort of hopefully we don't need this many seats, so we're going to grab the seats so wait for that to happen before you set up shop.

And it's important to note that there's organizers and staff at all the venues, so if you have questions when you're there about anything then you can find them, they have nice T shirts and stuff. And we're coming back here in the evening, so make sure to meet back here before 5:00 in the evening. And there's a super secret announcement, so secret I don't even know what it is. So that's exciting. And have a great time. That's it.

...(APPLAUSE)...

.

(End of.

>> You can see some people getting their signs ready, so make sure to find the appropriate people.

(End of









HELLO, WELCOME BACK. How is everyone doing? It's the one last WOO of the day. All right, we have one more talk for RustFest 2016. Our next speaker Marijn Haverbeke is someone you may know from the JavaScript DMUNT and he's also worked extensively with rust on the compiler and he's here to tell us a little bit about the rust that could have been.

...(APPLAUSE)...

MARIJN: Here I'm glad so many people still showed up at the very end of the conferencement I'm going to be talking about mostly a number of features that were part of the rust language at some point but no longer are and why this is the case and usually why this is a good thing. So as Ryan said I'm Marijn Haverbeke, if you are into JavaScript you might have seen my name before, and so Rust has been under development for about 10 years I think first one stretch was working in isolation and who knows what kind of ideas and experience that were done at that point there's not even like a repository from that time public so it is like the pre-history, and then at some point MOZILA adopted the project and assembled the team from a little before that point we do have GIT history and at that point everything was discussed in issues and mailing lists and there's lots of records. I was part of this pretty much the initial team where we moved from the original compiler to a Rust based compiler got a bunch more people involved in the language, this was a period of like the first real experience at the language and a bunch of people from different back grounds giving their opinions on the language and trying to push it into their favorite direction and we had a lot of experiments and overalls and false starts and just lots of CHURN have a good morning off in the afternoon, because it was only one code base we fixed everything right away and people could continue working. There was some trick can Iness with actually getting a compiler that compiles the current code after you make a breaking change so you first change the compiler upload the snapshot and change the code and everyone could proceed with the new snapshot and then of course a year and a half ago I think the team cuts version 1.0 and then the process changed entirely, so now LTS like everything stays backwards compatible it's impressive how serious the backward compatibility, and experiments move like our Cs moves very slowly and there has to be a wide consensus and fit within the current code base.

So that's a whole different stage, again.

I'm going to be mostly talking about the period where I was part of the team, which was 2011 and 2012, and which was probably the largest period of features cut and change, stuff like that, so it may seem a bit ridiculous that we put so much time into so many complicated features and dropping them again but I think that's an essential part of get ago complex design like a program language right that unless you're a super general YUS you won't see in advance what the implications and interactions between the various parts of the system are and you have to try it and see how well you can make it work and how well it fits into the system and sometimes you later have to just abandon it again.

I think that's part ave healthy design process for like mere MORT TALS who need to actually see how something works before they can evaluate it, I'm stretching this talk around a number of visions that were part of the language and then dropped again, and I'll try to explain why I think in every case it was a real good decision to drop them, but it's still interesting to see what the original visions were and what we did end up with.

So these are type state, a structural type system, and light-weight processes, finally garbage collection. Let's start with type state. Type state is -- it was actually an important point initial announcements of the language and people were very excited about it, what type state does is basically allow you to -- allow the compiler to know more about the value than just the type, so an example would be this is something of type circuit but we also happen to know that it's open or this is something of type array that we happen to know our vector in the current terminology we know it's not empty. Something like that, allowing you to add more safety to your program, more static guarantees.

So when you're programming you usually have a mental model why this thing you are doing right now is valid, is not going to crash, if you're not just making random changes and seeing the test pass you will have some mental model of your program. To a certain degree, depending on the language, you can tell the compiler about this model and the compiler can check whether you are applying your model consistently, so in simple cases just types you're actually passing the type that you think you are passing somewhere and if you don't instead of finding out at run time you find out at compile time, this is nice, basically kind of a this computer does not have the fonts that my computer had, but imagine arrow heads on both sides, there's a spectrum on which languages fall in terms of how much can you actually communicate through the compiler, so on the one side JavaScript synthetically correct let's go ahead and run it, then on the way other side there's language requires you to actually construct a formal proof that your program does what it's supposed to do, that it does so in bounded time and bounded space, which means you're making a lot less mistakes but on the other hand it's like a major project to write a small program in such a language.

There's a reason that not everyone is writing their web servers in cork or whatever, and risk kind of falls in the middle it does have quite a bit of static guarantees and it helps quite a lot but aims to be easy to program, where you don't have to spend too much time working on these things. One way to see the history of programming language is kind of one aspect of this at least that we've been finding better and better VOE cab BLAER to describe the things we know about our program to the compiler in way that's actually convenient so if you have a really terrible type system that's often worse than no type system at all if you have to choose to write something in java or JavaScript I'll take JavaScript, thank you very much.

We're getting better in this Rust is making a big contribution, making a system program space and ownership model is I think really good. I unfortunately wasn't on the team when this was introduced so I can't take credit for it but I think it's the most XOOITing part of Rust and it's this kind of thing where the compiler knows what you're trying to do and tells you when you're violating your model.

So back to type state, it looks somewhat like this, you could define predicates, which is this pure function at the top, and the extra information that L the compiler had about your values came in the form of this predicate holds but these were just predicates written in normal Rust codes that were supposed to be pure, there was a problem with the affect system at that point that's gone now, they took a value and said I hold or I don't hold.

And then you could define for your functions pre conditions and post conditions, so you could say, for example, this function lost, here, demands that it's first arguments has the not empty predicates holding on it, because you can't take the last element from an empty array, and then before you could file such a value to such a function you have to convince the compiler that this predicate held at this point. And for some things this worked well, the compiler was very clever in propagating its information through the flow graph and taking it from the post conditions of the function, but you have an example create an array and pass it through lost, but that's not okay, I first have to check that it's not empty, and this actually is the same check would insert a run time test called to the predicates and then panic if it failed.

So we're actually I mean this array isn't empty this is very easy to prove because the compiler only saw these predicates as opaque pieces of code it couldn't actually reason about them, it could only take what you told it, like if you check the recurrence of check one was a just believe me just hold, so it might also have been appropriate here because I'm sure this array is not empty, and then there was one version that ensure that the compiler already aesthetically knew that it was something else, it was an' SERGS of okay I must know this at this point, but don't insert a run time check, I want to have aesthetic error if it's not provable.

But it in my experience the affect of this system was that you would be littering your code with check statements and they would also panic at run time, so the aesthetic, amount of aesthetic guarantees wasn't very great because often usually the compiler couldn't really help a lot with reasoning about when they actually held and when they didn't.

It was in the compiler for a long time still but eventually it was dropped because it was not pulling its weight so in terms of experiments in good expressive ways to express these kinds of things I think this was a failed experiment, but existed some research languages before but it's never really made it into a big mainstream type language, for good reason, I think.

So so much for that.

Next topic is structural typing so in typing systems you have two concepts where structural typing is say you have a function type, which has a few argument types and a return type and you want to compare it to another function type so you're just going to look at the fields and the function does it have the same amounts of arguments, are its arguments of compatible types, is it return type of compatible type, and that's structural.

On the other hand there's nominal typing where you just say where is this type declared what's the name of this type and it has to be the same so Rust currently works this way as do ENOMS are only compatible if they're actually instances of the things that are of the same points in the code.

Initially structure -- structural type so this currently brace this thing there is syntax for STRUKT type with two fields X and Y of type flow and the type decorations defines an alias for that type this is a name for the type record with two float fields and so if I define a function which takes an argument of this point I can call it with just a record constructed on the fly without any record name involved, records themselves don't have a name just a structure and a system and it's kind of nice and light weight and minimal and that's often you don't even bother to give your record a name if you only use it a few times, so you -- well you would now probably use it you can use TD record nice descriptive field names, I kind of liked it for programming with, but I'll come back later to why this part was removed another object of this was object type whereas structure types were only come pattedible if they had the XX same fields and in the same order, they weren't reordered because see compatibility and they had to be the exit same to be able to compile it efficiently, because then all codes are then DREKTSD with such a record knew how it was laid out in memory, objects were more dynamic feature and here any object type that has a subset of the fields, fields are always mattered so they're always functioned that this object type has it's compatible, so I could if I define the type a collection of T with these two is probably not a very great fraction but bear with me with a length and an item access or method you could take any objects that had I don't know what kind of methods but also these two and you could treat it as a collection of T.

So these were both the types of the concrete objects and roll of interfaces in terms of how much concept you need in terms of programming and could you also use it as a kind of checks duct typing where you define your function and just say I'm only going to call length on this thing that I'm getting, and then anything that had a length method could be passed in you don't even need to formally define an inter face name it's all structural by name.

So one implication of this was that because code that used didn't know their side they had to be garbage collected and any calls to them will be going through dispatch table a V table. So they're somewhat more heavy weight compared to the rest of the language, and we were finding that in the compiler we were SHIEG away from them unless we actually needed polymorphism because there were more heavy weight than necessary in many situations, and then at some point well there was also a lot of machinery involved in actually doing this like up costing to a type with less methods because then you needed to locate a new V table preferably aesthetically which create a wrapper, it was conceptually simple but not terribly simple to implement and then at some point we got more high school people on the team and all started agitating for a type class kind of implementation inter face thing that we ended up now and because no one really likes these objects very much we migrated to that, and I think they just fit with the language much better, they don't require you to put something on the heap, they don't require indirect calls unless you actually are using polymorphism, so I think that's a win.

But now that we had implementations, which affects a specific type, structural records also become problematic because if you're using a record that happens to have the same shape and two completely independent contacts and they both define a two-string implementation of it then these will clash even though they have actually nothing to do with each other they'll try to implement the same inter faces trait with it that doesn't work no one cared that much about structural records either so they became nominal for this reason, at that point.

And now of course people send functions are still structural they don't make much sense in any other way but heavy emphasis on structural typing was abandoned, again for good reasons.

And then so some -- we saw talk about asing chron news and synchronous programming yesterday, and there are languages like let go and erline which solve this in a different way, where they look synchronous that is like a slight of hand they're programmed sing cruise newsly but you don't pay for I don't know how many threads, it's more live than operating system threads that was part of Rust's initial vision so you don't need to mess with futures or reactors or anything you just spawn a bunch of tasks which for example each circuit or you could even if you are writing a calendar spawn a task for each task on the calendar or something, and they run as independent pro

esses but because they're designed to be cheap you don't have to worry about allocating the lens of them it just works.

Now it's not designed with this in mind they come from a period where people were not considering the lens of thread a reasonable thing to do and usually their internal data structures as well as the minimal overhead on a thread is too much to use to operate every circuit on your rep server.

So what you have to do then is you create your own tread pool in the language run time and you have your own task threads are picking up tasks running them for awhile when they block or time runs out they put them aside and take another task, they do their own scheduling which is also not reveal and of course even if you do this you still have the problem that that's simple opinion code has this conception of a stack where it can allocate stuff in like last in first out manner where it's gross during function calls and shrinks again when you return and that depends on infinite stag being there, they're not actually infinite of course but they're usually big enough to allow reasonably occurred programs to run without overflowing your stack. But that means big enough is quite a bit, you're going to not want your minimum stack to be half a kilobyte because then every program will overflow it.

So we got away from this simple stack model and introduced segmented stacks which are stacks where each function that once allocate on the stacks first checks where there is enough stack and if there's not enough stack it allocates a new piece of stack and kind of links that to the current stacking and runs on that and when that function returns it will throw away this piece of stack and return to its all stack.

O that's not good can you give me a cable?

(Laughter).

MARIJN: Got one. I hope there's a power thing, here. There we go.

...(APPLAUSE)...

MARIJN: The reason we don't just like grow the stack and copy all stuff onto the new stack is that would involve moving values in memory and that's a whole different can of worms and all the code has to be able to locate every pointer to rewrite it examine if it's held by some C code then who knows where it should be rewritten, so that's why we actually preserve the old piece of stack and then continue on a new piece. That's actually like quite a magic trick, but it works. It went for awhile this way but it does have some drawbacks, the biggest one is that if you have like an inter loop which is going to be running very often and that is exactly at the point where you're crossing to a new stack segment it's going to be allocating and throwing away so many stack segments like some of our BEFRMG marks I think it happened only once with our bench marks but it was ridiculously flow because of this like the stack switch happened exactly at the part of the benchmark that was running millions of time. So that's not a great obstruction it's kind of leaky it also has issues if you called C code it won't be managing segment of stack so you have to provide it with a big stack so we have a pool of big stacks and whenever you made a phone call you would get a big stack and then column that stack, there's lots of complexity if you want to call Rust code from C you have to arrange for the stacks to be in the right shape it worked but it wasn't great, and so this whole ambition was given up in terms of we don't want to pay that much run timely BRAER complexity we don't have all these problems like our own stack problem all these checks inserted into the code to make sure there's enough stack that's allocated there, and there the call was made to just not do that, so that we could be the kind of language that you can just link into a C program without pulling in I don't know what kind of obstructions and problematic factors, the kind of thing that you can write an operating system and that would also be a lot more challenging if the language depended on a big run time.

So no go, like light weight truss and it's cool to see the kind of solutions that are being found as in Tokyo and these kind of cheap futures.

The next one is kind of a similar story, so we start out with garbage collection because most of us were coming from garbage collected languages as a kind of in terms of okay this is what good language looks like, and we felt that you can't really provide an ergonomic language if you DOINT provide GAR GAJ collection. We did have a model that you only use garbage collection when you wanted it was opt in most values would be on the stack and you could have I think unique pointers at the time just what the box does now and you could WRIELT whole programs without ever using garbage collector but at the time the REFRJS counted garbage collector that was cycle breaker but there were plans to make it more a modern style of garbage collector but again this has a cost that is a bunch of run time complexity that you're pulling in, you have to deal with, like, what if C code gets a hold of such a pointer how do you know that we can't garbage collect it, so again, the complexity was doing too much this was quite awhile after I left and then Patrick Walton announced we could get rid of the garbage collector and my initial reaction was no, that's ridiculous, but then he explained, like, and it finally clicked for me that we could really be in the same niche as C++ is which I think the hugeest thing which is the reason why Rust is successful it can be run time without any complex machinery around it so it's capitulating to the simple mind that's programming model that we've been using for ages as a kind of baseline which is a shame in a way because it's not perfect but it's for systems programming it's the best we have and enabling allowing this language to be dropped in where you would normally use C++ is probably its biggest selling point and I got it and it was like okay this is a future that I can be excited about and I think it was actually relatively painless because you can swap in a reference pointr and have to be a bit more careful about cycles and that's all research work being done about integrating with garbage collectors and other systems but I don't think it's moving that well and, I don't know, I think we landed on a -- on a really good place, here, in terms of how bare bones the language should be.

Yeah, this was an example from the book that I wanted to show, it's not entirely painless not having a garbage collector returning a closure looks like this and it's not exactly half skull, but yeah, okay, I mean it's a compromise we have to make and I think it's worth it. Yeah, thanks for listening, I hope we still -- I think we still have time for a few questions.

So yeah, let's hear --

...(APPLAUSE)...

>> We have two minutes for questions, so does anybody have a question? I saw your hand in the back, first.

>> Audience member: Not that I would encourage someone to do that, but wouldn't the structural type kind of thing work like a template or like a generic would work that you could like generate a specific implementation for a certain type and then work without a V table?

MARIJN: Yes, you can, actually. And I think LOV somebody is clever enough to do this for us where they can see it was always the same V table and in line it but you're still paying a conceptual cost for it and I think it's easier to have a model where you don't generate this complex code and optimize it back where you rely on these clever opt Tim Ms. SGLAGS contribution.

>> One more question?  I saw you.

>> Audience member: Hi so recently I saw either an RFC or Rust internal red where someone was proposing these anonymous struts like you had in your --

MARIJN: Okay.

>> Audience member: You didn't touch that much on why they were removed I wanted to know why that would be a good thing to add into the language my personal opinions is fairly favorable I think that would be a good idea.

MARIJN: So the main reason as I remember if for removing them at least at that point I think we saw it do we make the structure we have nominal or structural the reason for move to go nominal was they worked terribly with trades, you can't have this coherency where you're guaranteed even if you link multiple modules together you don't end up with the modules together with the same trait same type that's the reason for that.

>> We do have now we can make trade implementations for these large too poles but it's not generic integers.

MARIJN: You have to do that in the trite that defines the trait, you can't do that anywhere else and that's a restriction that, yeah, it could work of course you would wrap your struts in some other type and define it on that if you're ready to define a trait in a different trait it's not very easy or convenient.

>> Thank you.

>> Unfortunately, we're out of time.

MARIJN: All righ

.

>> I'm sure there will be some time after wards, so now one last round o

applause, please.

...(APPLAUSE)..



>> So RustFest is coming to an end last thing we have is our closing present takes, which Florian is bringing up now.

So did everybody have a good time.

>> Yeah.

...(APPLAUSE)...



>> Yeah, one MOR time, yeah.

...(APPLAUSE)...

>> That power is sort of infectious, it's kind of weird. Any way so to recap what we had this weekend was 185 attendees here, and we had 13 speakers, if the speakers are still here can everybody come up on stage for a picture? And while they're coming up everybody give them a big round of applause.

...(APPLAUSE)...

>> Thank you, speakers.

...(APPLAUSE)...

>> We also had our first Rust bridge workshop. I know I'm looking forward to talking to everybody that was there, how it was, it sounded like it went really well, here's the picture of the Rust bridge, first Rust bridge.

...(APPLAUSE)...

>> So to close off things we're going to bring up Florian who is going to end this thing with a bang.

>> Well first of all a round of applause and thank you to Ryan LIVAC our MC.

So first of all, it's me doing all the talking, but this is a team event and there's been a lot of people involved, so if the whole team could please come on stage?

...(APPLAUSE)...

>> So we do have the most awesome of issues, which is Ben is missing because Ben took the use of the U1 to change for the U6 which we told everyone they should not because the connection's blocked.

...(APPLAUSE)...

.

(Laughter).

>> So while the picture is taking left to right Eric who's been doing all the cabling and wiring, thank you.

...(APPLAUSE)...

>> We have Katrina who did accessibility support all the printing the badges and all of these things and a lot of the reception service, thank you, thank you, thank you.

...(APPLAUSE)...

>> We have JOHAN who has been our best contacts -- no FLAKE is our best contact or they should fight it out, I don't know, two members from MIZOLA Johann is one of the founders, FLAGE is the person with the fire foxes so thank you, two.

...(APPLAUSE)..



>> General is a little bit accessible he moved over to Germany to be here today. A month ago.

...(APPLAUSE)...

>> And Ben from the open tech school also has been awesome and mailing people, talking to people, getting the phone calls out and getting all the stuff done, thank you, thank you, thank you.

...(APPLAUSE)...

>> And of course Florian without whom it would not have happened at all, Florian, thank you.

...(APPLAUSE)...

>> So and then we do have -- we do have another wheel we have the rest of the team who couldn't make it here due to visa reasons, from the Ukraine Andre and JANA, hi.

...(APPLAUSE)...

>> Florian: Can do you that again?

...(APPLAUSE)...

>> Florian: Sorry I think I cut the ATMI cable, sorry. So I've got a couple of other words to say. This is still a thing and for us it doesn't fix it, so a word about what is RustFest, so RustFest, et al was a bit of the idea what could a Rust conference be, you're rarely in the position to say we're running the first conference at someplace, and so we had a couple ideases of things we wanted to do and put trade bounds on that, first of all, we wanted to be as open as possible as a conference, so we wanted to be approachable, we wanted to have be open for ideas and try things out, for example how does it work if we send everyone around town to run workshops instead of another set of talks. We would like to have feedback on that, maybe there's little things we can improve, did you like it, did you like in general, did you like it not, please approach us.

We wanted RustFest as inclusive as possible, it's at the core of the Rust communities it's one of the only one that is had a code of conduct from the start and they say if we didn't have it I wouldn't have given you Rust we have that to but we wanted to put out an accessibility statement out so that people with accessibility needs could attend and we wanted to do our best to do this and we wanted to make the conference affordable so even at the price the conference cost we still had a discussion were the prices too high, we would really like to have this conference at least cap out on that level when it comes to other additions or if there should be any.

So the other thing is it's a community so it can always be imperfect and that's the nice thing this is not a full production by a professional team everyone here is unpaid for that and doing that in their free time there are issues people getting ill and all this kind of stuff, so this is something that we want to keep for this conference, don't expect this to always be like a perfect thing.

So one of the things I want to say there, if you want to run a conference and meet up or camp or something like that within the Rust community get in touch as the RustFest team or get in touch with the community team under the e-mail community team@rust link.org we're always accessible, if you tell us you're going to run something we'll find some way to support it even if we just get the word O out for you so please approach us if you want to be involved in anything there.

So which brings me to the question, next RustFest.

(Laughter).

>> Florian: Which I'll let these two people answer.

(Inaudible).

>> It's going to happen next spring and it's going to be amazing and it's going to be affordable and it's going to be for everyone. We can't wait to see you all. We can't wait to see you all coming over, see the city, see each other, and just enjoy Rust, enjoy the conference. YAY.

...(APPLAUSE)...

>> Florian: So this answers the question that has been asked at least five times yesterday and I'm too bad at clicking the windows so next RustFest April 9th, 2017, in KIEV I hope pencil it in, you're going to find news on our website so you can still sign up for the newsletter on our website and you have the announcement in your box.

Thank you.

...(APPLAUSE)...

>> Florian: Also having never managed to be to KIEV I'm looking forward to this, we have one final thing the organizers are going to spend the evening together you're invited we're going to be at the beer garden you can take the U6 because you don't have to switch.

Oh, thanks, one of our team members is sick today, I'm very sorry and I forgot it in the rush of the announcements so AMAR who has been running the registration desk yesterday and also organizing a lot of communication with the venue and hotel and everything is sadly sick today. She has a twitter account so tweet a thank you to her if you want to. I'm going to tweet the twitter account around later, thank you.

...(APPLAUSE)...

>> Florian: So this is basically the way you take the U6 I'm going to tweet this out, although we were going to bring a lot of stuff back to our offices and everything, so it's going to take us some time until we are there, we'll trickle in so if you want to go just go and we'll be in later.

Which brings me to FLAKE who wants to take a family photo.

>> No, no, it wasn't actually his idea, so yes, yes, more, please, more bottles, so yes, we are going to make a family photo and we want it to be awesome and we need your help for that so we're going to line up along those walls, take a photo from the right to the left, for that obviously there is some obstructions in the way and namely these chairs, so please let me ask you to help us stack these chairs up and bring them over so we can make the family photo and we can all look cool and set a precedent for next year's conference.

Next year we're going to crowd source awful our logistics. Thank you so much. I hope somebody was run ago stop watch because I cannot believe this was so fast. So if you don't have a chair in your hand please start lining up not right next to the wall but look up, look up, stand one meter after the wall, so if you're standing behind next to the wall step forward, three steps, that's at least two steps, one more step forward, one more step forward, people. That should do.

Yes, make sure -- make sure you're not obscured by Rust stations, cruise stations, crabs and other sea and animal life Get closer together, people, we still have too many people.

From the right-hand side there's too many also a bit dark, please try from the sides try to move over, try to snuggle a bit more. Kick them in the shins. No, no, we are still having a code of conduct. Can we have this light a bit brighter? I guess that's a no. My German's a bit rusty. Oh, perfect. Thank you so much.

DANKESHE

screams
----------
