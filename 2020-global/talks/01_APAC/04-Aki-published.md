**Using Rust in Metal Fabrication**

**Bard:**  
Aki has the unbreakable will  
to get Rust to the metal, to mill  
it into shapes snappy  
make customers happy  
though this battle is somewhat uphill


**Aki:**  
All right. Thank you very much. Good day, everybody. Thank you very much for joining me today. My name is Aki. Today I would like to share some of my experiences using Rust in metal fabrication. Let's get started. Of course, I am not referring to this kind of oxidized kind of Rust which is generally not very desirable in metal fabrication. The oxygen in the air reacts with iron to form the weaker substance we know as rust. Today I would like to explore uses of a more desirable rust. The Rust programming language and share my experience using it to develop enterprise software. Today's talk will be a primarily non technical perspective on using Rust in the development of enterprise software. What is metal fabrication anyways? Well, it refers to the manufacturing process that gives us these goodies in life. Large parts of this Ferari are made from metal. The engine blocks are carved from large block of metal and the hub caps are created through metal fabrication processes. It also brings us the metal factory equipment that bottles our beloved Coca-Cola drinks and the belt conveyer that run the Amazon warehouses that bring the boxes to our front doors. And of course, our beloved gaming rigs with the metal power supplies and the cases all made out of sheet metal bent and cut into just the right shapes.

So, let's take a look at what the processes are that are used to modify the raw metal into the these goods that we know and love. I did what anybody would do and asked Google image search what metal fabrication was. As you can see, a lot of metal and lots of sparks. On the right here, we see a welder. This is a process known as welder where metal parts are melted to form one solid block. Here with more sparks we see a laser cutter which uses high intensity laser beams to cut shapes out of sheets of metal. As we can imagine, these are expensive, high precision machines and using this manufacturing equipment is very, very important to the success of any manufacturing operation so the metal fabrication industry benefits quite a bit from the use of software to run the business. Software is used throughout all phases of metal fabrication from design and simulation on the left all the way to final delivery on the right.

In design, we have CAD 3D model, computer-aided design, where the end product is designed on the computer using simulation tools for aero dynamic testing and whatnot as well as something we software developers know as version control, the equivalent of making sure that various iterations are tracked and the differences can be seen. Once the design is complete we need to go purchase the raw materials. This requires the exchange of money and that requires workflows and integration with counting systems. Once the materials are on hand, then we need to make sure we utilize these expensive resources, the manufacturing equipment and scheduling workers and the machines to optimally plan the manufacturing system. Most -- once it is created we need to deliver it to requiring this forklift and track inventory and know when it is finally delivered. Most of the information in today's talk is around my experience developing the right hand three and developing software for these areas. Purchasing, manufacturing, and logistics. These three areas are created primarily when we organize that information and 
track the flow of physical goods and the money.

A brief overview of the system architecture. My development team builds enterprise software using the browser as the primary interface so our architecture looks very much like a web application with a front-end and some back-end processes. But one of the most important things that we have done is in enterprise software the Des Moines -- the domain is complex and we are achieving a higher level of efficiency separating this out. On the left is the front-end which is designed to optimaly present data. The BFF is a TypeScript node.js process its role is to fetch data from wherever the data is whether it is an API, another system, a third party API, whatever it is its job is to go and get the data. And finally, the backend. This is written in Rust. It's goal is to enforce that the main model and maintain data integrity. This is the area that I would like to talk about today.

First, I would like to cover some of the technical aspects of using Rust specifically using Rust in the domain driven design sense. And second, our impressions of the library ecosystem. The main driven design is one of the most important concepts we value in the development of enterprise software and it is a coin termed by Eric evans in this 2003 book emphasizing the importance of for software developers to understand the real world domain and try to model and express it in software. So, as an example, in metal fabrication we use paint to prevent rusting, given the various paints and colors, let try to create a data structure to express the color of paint in Rust. RGB is a way that we use often in web development and let's say 8-bit colors can be used. Take in printing and we may need to use CMYK so another expression of color with a different set of tuples. Coming from C++, this way of expressing typed unions in Rust has been incredibly powerful, but as with all things in the real world, things were not as easy as they seem. We found in certain areas of the industry, our customers didn't know what color they wanted or were not able to give us an RBG or a CMYK color they wanted. They had a physical product they made and wanted the same color as that. As an industry and a manufacturer, we need to make sure our enterprise system would be able to handle this new way of specifying color so Rust enum allowed us to do this. Create a way to express physical color sample. This was a simple way to know we needed to get the physical color sample from the customer. Handling this color is easy with a match statement. We can easily decompose each RGC or CMYK and utilize them appropriately. And the Rust compiler and the ability for the match statement to tell us when we are missing things has actually saved us many, many times. Here, the commented outline, for physical color sample in the match statement would generate a compiler error and so if somebody modifying the domain model, or the actual struct, did not realize all of the places where it was being used, we could simply ask the compiler to detect it for us.

The next aspect after enums that we have utilized extensively is using phantom data types as markers for compile data type checking. We use money in enterprise and we use multiple currencies and so if we were to have a money struct here, of course, we would have an amount as some kind of decimal value and the currency could be held as some kind of string but that would require us to do run time checks which are, of course, sometimes necessary but when we have business logic, coded in, we often want to have compile time checking. By using phantom data types here, we can create emums for a Japanese Yin or U.S. dollar so when we create a statement like this where we try to add the Japanese Yin to the U.S. dollar we would get a friendly compile error that tells us exactly what happened. We use this not just for monetary types but also for physical types such as meters, length versus volume versus area. It doesn't make sense to add volume to a length, for example, and using these kind of phantom data types has helped us extensively and optimized our development process.

Next, I would like to talk about some of our impressions of the library ecosystem. The good parts. We actually found a very high-quality coverage across our needs. We use rabbitMQ, Redis and Postgres and gRPC. We have listed libraries we have used and had good experiences with them. As for the wishes that we had, it would be great -- it would have been great if we could find more production use-cases because production ready can be a very subjective term but the real world -- using a real-world product as an example really adds concreteness to it. We started using Tower-g rec pc because linkerd was using it.

When async/await rolled around we were not sure about jumping on the bandwagon and in the end we don't use it. We horizontally scale until we can handle it. Some guidance as to where the async/await is going is interesting and we are watching the community to see where things are going right now. And finally, I would like to cover some things that are non-technical. Primarily, hiring for Rust, new engineering training, and how to maintain a good community within the development and finally, a bit about the community work. Deciding what qualities to look for in a candidate when your technology stack uses Rust is incredibly challenging because it is such a bleeding edge technology and so new that compared to other languages that have been around for a lot longer it can be hard to figure out what to write in a job description. Here in Japan, one of the ways that we have decided to do hiring is to look for the core aspects of what are the attributes that make somebody a good Rust engineer.

For us, what worked and has worked for the last year or two, is the familiarity with a type system with traits and generics or something resembling that such Java or TypeScript as well as functions of functional programming and familiar with computer architecture and management and low level aspect of how programs run. Of course, if somebody had all three of these aspects, they probably already have touched Rust a little but, but we have found many engineers from other languages have been very, very successful using Rust in the development of enterprise software with us and it was because of their strengths in one or more of these areas. And as we with many engineers, we don't write code just to write code but we write good code to make a change. Enterprise can be kind of a black box so we have made efforts to make sure people know what we make using Rust and what is Rust being used for and how are we optimizing the metal fabrication supply chain using Rust? And once we have new hires, training them has been required new kinds of efforts because sometimes relearning new foundational concepts and learning to talk with the compiler. We have found once people get used to talking to the compiler they don't need very much hand holding. They will get up to speed very, very quickly. And finally, Rust is good at some things and not as good at some other things so making sure everybody is aware of how our development team uses Rust and where we choose not to use Rust. In the development of the frontend it is probably much easier to use React than to use Rust. And as a development team, having a critical mass of Rustaceans is critically important because it allows us to create a community within the development team and fostering a culture because the ecosystem is changing constantly and the language is always evolving. We have found fostering this kind of culture has been very, very important to the success of using Rust within our development team. And finally, the success of the Rust community contributes to the success of the business and our development team. So as an enterprise software development corporation, it is important that we participate in the community and so, with the pandemic, here in Tokyo a lot of things started shutdown in March so in April we started an online Meetup called Shitamachi-rs. We believe it is important to keep the community alive and make sure there is constant innovation and that people are always engaged.

And with that, I would like to give a few closing words about using Rust in metal fabrication. Metal fabrication itself is a very, very complicated realworld domain but Rust has been an amazing language for developing this software. The library ecosystem maturity has been actually good enough for us but at the beginning it was a bit difficult for us to gauge. Using Rust itself has been technically an amazing experience and from a non-technical perspective, different kind of efforts were required for hiring and training to maintain this kind of efficiency in our development but the friendly and welcoming committee has been absolutely wonderful. The resources are available in Japanese as well. So, as my last words, let's, as corporations and any enterprise user, or any commercial entity, or any development team for that matter, I think it is really, really important to share real-world use-cases of Rust and to really support the Rust of the community because the success of the community gives back to the success of every project that we work on. So thank you very much for your time today. It was a pleasure.


**Moderator:**  
Thanks, Aki. If you have any questions, please, leave comments to the chat. Anyway, there are some questions... Aki, Do your Rust structures touch or mirror your Typescript types in your BFF layer in any ways? 

**Aki:**  
The Rust structures are reflected in the TypeScript layer, in fact. It requires -- we use GRPC in between and we can share some of those definition files so that we can do it easily and translate them to both sides. However, of course, the type systems are not exactly the same in Rust and TypeScript, so there is a little bit of messaging we need to do to pac sure we can handle it but Rust and TypeScript have similar notions and that has been instrumental in optimizing or to increase the efficiency of our development process. 

**Moderator:**  
Any other questions? OK. Thank you, Aki. That's all. 

**Aki:**  
All right. Thank you very much.
