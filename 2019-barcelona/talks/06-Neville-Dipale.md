Powering Crowd-sourcing of Public Transit Delays with Rust

Live captioning by White Coat Captioning

NEVILLE:  Good morning, everyone.  This talk is going to be about powering crowdsourcing of public transit delays using Rust.  Morning, everyone.  My name is Neville Dipale.  I'm from South Africa.  I'm on Twitter.  I work as a data engineer, mostly as a freelancer.  I started as a hobby about ten years ago now, I run a public transit info service, I started using Rust about a year ago and recently became an Apache Arrow committer contributing to the Rust implementation.  
Today I am going to be talking about trains in our region and challenges with them so I will give an overview of how they work, I will talk about the crowdsourcing solution, how we use Rust and what the benefits of having used Rust are.  So as a background to the train service, we have two train services in our region.  Out of interest, how many people have been in South Africa, by a raise of hands?  Cool, thanks.  So we've got two trains and we've got the fast train and the metro train.  The fast train was actually built for the 2010 soccer World Cup.  We hosted it, and won it.  The metro train has been around since the 80s so it has very aged infrastructure, they haven't replaced some of the trains in quite a long time.  The metro train is very cheap.  You can get from one side of the province to the other side of the province for about 2 to €3 and then most trips would be 1 to €2.  The fast train is a bit more expensive so it goes from the airport into the city and you pay about €10 a time for that train so the metro train is used mostly by poorer communities and students though rely on the service.
Let's guess which train is which here.  We've got this one.  Which would it be?  Fast train.  Then you've got this one, being the metro train.  [Laughter]
So we've had this problem for a very long time where, because there aren't enough trains, they get overcrowded and people get desperate to get to work and then they hang on to the trains.  They are changing that now with new metro trains but we've had problems over the years with procurement, government issues, etc.  We were supposed to have these new trains about four years ago.  I think now there's only three running and they've promised that we will have all of the trains being replaced by these ones in the next ten years so the struggle is still going to continue.
With metro train delays they've got severe infrastructure issues, as I've mentioned.  It's estimated that 40% of rolling stock, ie the train coaches, are out of service, are not available, and this affects peak time services quite significantly.  It's only during the day when there's fewer people taking trains, fewer services, where they get to catch up and then the same problem then begins again in the evening.  Trains can get stuck in the middle of the tracks, cable theft, signalling problems, etc.  It's not uncommon to be on a train, stop in the middle of nowhere for 15, 20 minutes, and then the train continue again.  I did an interesting analysis - not here though, for something else - where we were looking at the average train travel times, factoring into account the delays, and one of the trains took about - I think it travelled at 30km/h effectively and was travelling about 100 kilometres so you can imagine how long that train trip was.  Delays of over 60 minutes in most cases.  Part of my pitch, it was dramatic, I said, "Your train is arriving in 20 to 90 minutes", because that's the kind of uncertainty.  
There are communication issues also from the operator.  None of it is digital, all of it is analogue.  We don't have an API that provides information as such and a lot of the times, even for the train to say move themselves, they rely on phones.  The train conductor will stop the train and say: can I move on?  Then they have to wait 10, 15 minutes or so.  In the past 15 years we've had a number of collisions of trains.  One big one, 20 people died or so, so it has been very bad over the years.
Here is a graphic that just shows some of the data that we've collected.  I've split it into delays, so a histogram of delays where the first two packets are trains that are early or on time and in the ten-minute category, 53% of trains are delayed by up to ten minutes, so this is great but also bear in mind that we don't crowdsource the entire network, so it's only a snapshot of some of the trains.  Then you will see that the delays sort of go down.  You still have quite a number of trains that are very late in most cases and each time, this is normally either in the morning, somebody has to get to work or a meeting at 8.00 am, they end up getting there at 9.00 and as a result a lot of people have lost their jobs because you would come late every day in the week and your employer just says: well, sorry.  There are people who wake up at 3.00 am just so that they can get to work at 8.00 am in the morning which is quite terrible, and then the same again happens at night, where people would leave work at 5.00 pm, if you work 9.00 to 5.00, and then only get home at 10.00 pm.  So our solution has been to provide metro commuters with information on train delays.  We use Twitter and push notifications on an android app, so we've got a android app that people use to process this information.  We crowdsource delays either by sharing a train trip or spotting trains so if you would have noticed on the first picture, there's normally 4-digit numbers on each train and we use those, map them to the schedule and people provide us with the train number and we figure out which it is.  We calculate delays based on the actual versus scheduled.  We use a linear model: if the train was supposed to be here five minutes ago, and the average speed has been let's say 20% less than what it should be, we just do a simple linear progression of what the delays would be.  Then we generate estimated arrivals at stations and then notify commuters about delays.  This is what we use Rust for.
Okay, so in terms of submitting train delays, the architecture is quite complex.  There's a lot of services that are running around because I have been doing this for about seven years now.  Some of the stuff is in Rust.  A lot of it is not in Rust but for the talk I'm just going to talk about the few components, specifically three components that are built in Rust.  We've got a location sample service that checks for sample validity and accuracy so imagine when you are crowdsourcing one of the problems that you have is that some information might be accurate, some might not be accurate.  There's nothing stopping a person from saying: I'm on train 1235 instead of 1234 and then they give you incorrect information.  One of the things I saw in the early days of deploying this was a train that was moving in reverse and it took me a while to figure out that somebody is actually on the other train but they are submitting train locations for this one, so it looks like the train just keeps going backwards.
Then this location sample deals with that.  We've got a service that saves samples in the database.  I will explain more in detail about that.  Then you've got a Vehicle Stream service.  If you were in Rust Lab in Italy I talked specifically about the Vehicle Stream service.  It calculates delays of trains.  The user sent delays was samples and then other users are notified of delays.  I will talk about this in detail.
Here is an example of a process.  So train A is expected at station 3 at 8.00 am.  There are no samples yet so we are just relying on schedules.  The users - different users are waiting for the train at stations 4, 5, 6 and 7 and those are the estimated arrivals at those stations.  Once we receive the first sample, let's say at 8.12 and that's between station 3 and 4, already for station 4 there's a delay so we will just project those and then I've marked them in red to show the users that you are notifying.  One of the problems is that we don't want to spam users and notify them every other minute to say your train is arriving in four minutes, now it's three minutes, etc, so we project those and then at the next sample that you get we only then calculate the difference in delays.  If the delay is still more or less the same we use a five-minute range, we don't notify the user again.  So when you get a sample at 8.16, the station for the train was already passed, the next one is at 8.25, it's within a four-minute difference, so we are not going on notify the user.  We are only going to notify the user whose train is now arriving at 8.33.
In terms of the Rust services themselves, the location sample is a gRPC server that uses tower gRPC, it receives vehicle samples and processes them.  It matches samples to trains and so we take the four-digit train number, match it to the train and generate a last known location.  It uses actix to monitor state of users and trains.  I will talk more about it.  There, I've just shown a screenshot.  I know Actor is more popular than actix.
We have a trip status struct that tracks the last known details of each trip.  Going back to the previous slide there, you see that we've got user trips and trips.  A user trip just matches the user to say - the user is on this train so when they submit another train sample, we automatically reject it because you can't be on two trains at the same time.  The trip just checks the overall status of a trip.  So in the trip status you will see we've got the trip ID, route ID, the last distance and then location.  The last distance is very important because we calculate the distance based on the geometry of the trip so if somebody submits a sample and says that the train is close to station 3, let's say it's 2 kilometres away from station 3, and another user submits a sample five minutes later saying: actually, it's close to station 2 - we are going to reject the second sample because the train can't go back in reverse so that's how we work around that issue.  Then also keep track of congestion and occupancy.  We are hoping that with a lot of users we will be able to reliably tell people that your train is actually full, it's better maybe to wait for the next one, if it's coming.
Okay, so we've got an actix actor that receives a sample and handles it.  The benefit is that I don't have to worry about multi-threading because actix has a mailbox so as long as I have a big enough mailbox to handle it - one benefit of Rust is that it's very fast so I never have a big backlog at any point in time.  The sample produces a location or an error if, for example, the location is invalid.  So after the service saves the valid sample onto the database before it returns it to the client, this sample then gets picked up by the next service that I'm going to talk about.  If you have worked with geospatial data, it gives vehicle co-ordinates and then some information about the vehicle.  So the next service that I then used is the Vehicle Streams so this reads data from a database periodically every 7 to 10 seconds and it projects the delays per route so this is for estimate and live - sorry, scheduled services and live services.  It calculates the estimates and keeps churning them out throughout the day.  It starts running from 2.00 am when the first train moves up until 11.00 pm when the last bus is moving, so it's both for trains and buses.  It sends all the results to a service, it uses nats.io for that, and then it uses a Tokio interval and runs it every 7 seconds to generate my sample.  How does Rust help with Vehicle Streams?  I first wrote the service four years ago, initially in JavaScript where a small crash would collapse the whole thing.  I moved it to Kotlin in the JVM hoping that it will be better, but then I had to keep throwing more RAM at it.  You will remember I talked at Rust Lab about going from 20 gigs of RAM to less than a gig of RAM at peak time so it took a few months.  This was about 14, 15 months ago and I'm seeing very impressive performance.  I previously talked about how the service just runs for months on end.  I never need to restart anything.  I use a third of the CPU usage.  I talked before about going down in RAM and the main benefit is that I was able to replace an in-memory cache with a simple HashMap.  I will talk more about this and then the service is easier to maintain and expand.
Then there's a notification service because I mentioned that users have an Android app so when one user is submitting samples, other users are relying on that sample.  It's a Firebase cloud messaging service.  I think it was abandoned but somebody picked it up and started using it which is one of the nice things about open source in general.  It notifies users about a range of things.  There's effectively a generic cloud messaging app where I can just keep on extending it by different types, so it's not really train-delay specific.  We personalise information for individual time delays so if you've got five people waiting for the train at different stations and you notify one user now, but the delay doesn't affect the other person, when it does affect the other person, the second user, we only notify them.  So we keep the state of each individual user and one of the things we try to avoid is spamming users by sending them hundreds of notifications per second because immediately someone will uninstall your app and you will never see them again.
The service also uses actix but instead of using gRPC we use nats.io, so within the whole architecture there are messages being passed around quite a lot.  I used to use Kafka.  Subscriptions are edited in realtime.  A user says I only take the 7.00 am train, or I only take trains from 7.00 am to 8.00 am, between station 7 and station 24.  So once the train passes station 24 we don't notify about anything because it's no longer relevant for you.  This is one of the nice things because the fast train service that I talked about, they will send you a notification about a bus in some far-away place not running an it's just irritating and a poor user experience.
All transit data state is loaded at start-up, when the application starts, and I keep it in memory so specific data like what the train numbers are, what the stop locations are, etc, as well as the trip data.  The benefit here is that we end up storing everything in memory because the application effectively, as long as the application doesn't crash, which is one of the benefits of Rust, it will keep running indefinitely.  So if you use actor systems quite a lot you will know that some actor systems support snapshotting where periodically you'll save the user state onto a database so if the application crashes you can recover that state.  Here, I don't use that.  I just load everything in memory and keep it running.
So why Rust then?  The main benefits are that I'm really getting stability out of this because being able to write a programme where I can prove to myself or to a compiler that it won't crash, I handle every state that will cause a panic, helps me to create a cheap in-memory store using a HashMap for example, instead of using bootstrap or something else.  I don't really use Rust for something very novel per se, but it's really just to give me the performance.  Actix has been good to avoid concurrency issues.  I rarely have problems with borrow check or lifetimes or anything because everything is simple.  The cost saving is the important element for me because this is a hobby and maintaining this means - if I was doing it as a profession or whatever I would need to wake up at 2.00 am in the morning to notify users of cancellations of trips and all of those things, and then stay up all day until late at night.  Because it's a hobby, it's very costly.  Every hour that I spend on this is a hour that I could be working as a freelancer and putting food on the table, etc, and also the other thing that I save on a lot is server cost.  Initially, about two years ago we first started using Rust, I had to have a 64 gig server because the Kotlin service would use about 20 gigs of RAM and all the other services would cumulatively add up so I used to normally run at around 40 gigs of RAM usage, just running this aspect of this public transit stuff and now the services that I just talked about in Rust, including others that I haven't mentioned in this talk, I can run all of them in a 1 gigabyte container with 2 CPU cores so that's significant for me.  The other thing is scalability in terms of performance.  I use two CPU cores but I use very little.  If we were to expand maybe even 100-fold I would still be able to use them within the same resources.
Okay, that's it from me.  Are there any questions?  [Applause]
>>  Hello, thanks for that interesting talk.  I already saw you at Rust Lab.  That's amazing.  About the scale of the thing, so how many users does this actually serve concurrently and what's the frequency of notifications and messages to users, just to get an idea?
NEVILLE:  In terms of the number of users, we get about 100 users a day submitting samples.  There's a lot more who receive samples but it's not very frequent and it's only really busy in the mornings, when a lot of people are taking the trains and then again in the evening.  Throughout the day you will see one sample once in a while but it's not a lot.  Then, in terms of notifications that are sent, there's a hard rule that says we won't send a notification to someone for the same train within five minutes, but we send about - the last time I checked, it was about 400, 500 notifications per hour, at peak times.  But it's still quite a young service.
>>  Any other questions?
>>  Again, a very interesting talk.  You mentioned you run it from about 3.00 am until late in the evening.  Does that mean you can shut down your service and, if you didn't have that option, would you have to change anything about your infrastructure?
NEVILLE:  So in terms of running it, the running aspect of it at one point is standing on a chair, looking at cancellations more than delays.   The whole delay infrastructure - it's the cancellations where there's a WhatsApp group from the train operator where they say: this train has been cancelled.  So those ones we can't automate as yet.  We have to capture a cancellation and send that out.  Everything else is just automated, so at night when - it's based on schedule, so if there's no scheduled trains that are running the service will just keep calling every 7 seconds but do nothing.  Once activity picks up, it starts running.
>>  Hi.  Great talk by the way.  I was just wondering, does the app send regular updates, or does the user have to actually send the update themselves?  Press a button or whatever?
NEVILLE:  My apologies, I actually didn't talk about how users submit.  There are two ways.  First is ... depending on where they are - when a train passes by you can spot the train by saying I just saw a train passing by and we use that one sample to calculate.  But then once you get on the train, if you've used Waze it's something similar, where once you get on the train you can say I'm on this train and then it will take a sample I think between every 45 and 60 seconds.  That's how we get the sample.  Then once you get on the train.
>>  Thanks.
>>  A very nice talk.  So you mentioned you store the state as a HashMap in memory.  Have you ever had the issue that the state got - you were not able to forget?  So something you use is ETL so you can forget an entry automatically; do you need to handle that in your application or is that not an issue?
NEVILLE:  So I used both.  There's a crate called ETL Index, I think, I cannot remember.  I used that for state where I want to keep stuff ... I restart the application once a month, I will just load that information.  I do do incremental updates where there are changes that happen and in terms of the application getting big, right now with about 7,000 services, or 7,000 different routes, yes, and 7,000 vehicles, I use less than a gig, so in the Vehicle Stream service I use about 500 megs and then for static information I use about 400 megs, so if I were to increase the service tenfold, still say 10 gigs of RAM so that's not a concern.
>>  Do you have trainspotters in South Africa and could you maybe change your app a little bit so that it gamified it for trainspotters?
NEVILLE:  Well, there's a lot of stuff I didn't talk about and I see there's a lot of questions about, so one of the things you do on the app is we keep track on - we've created a points system for trainspotters where based on how much the trains - how much you travel - the first person will get more points.  At the end of the month, because people are often students, etc, we buy them data in small prices that they can afford, and then the other one is we keep track of how many kilometres in total you've travelled and we also incentivise those people so we do gamify, because otherwise people don't see the benefit of spending their data helping the service, even though it helps.
>>  More question?  I don't see any.
>>  Do you know if the train drivers use the app as well, or do the company use it?
NEVILLE:  Some background, one of the problems we have in our country is that the government outsources a lot of its sources.  The problem with that is that, even when you are coming with good intentions, trying to help out, they can't just take your services, they have to go through permanent services and things like that.  We have put in a proposal a number of times where we said instead of putting GPSs on trains because the trains are old anyway and might get vandalised, let's create an app for train drivers because all train drivers have smartphones and then those drivers, when they get on the train, they can say: I'm logging in on this train.  One of the problems though that we have, because we've tried that with buses also, is that bus drivers are very unionised, so there's a lot of organised data and there's always issues about whether this information will be used to the prejudice of drivers.  Sometimes the drivers aren't very honest in the sense that when a bus is supposed to leave at 9.00 am or it leaves and every 15 minutes, sometimes the drivers will intentionally not leave at 9.00 and leave in a bunch together.  There's a concept called bunching.  There are quite a few issues that work against us trying to implement that but we are trying because if you do that then you don't need the crowdsourcing.
>>  Anyone else?  Okay, thanks, Neville, for your talk.  [Applause]
